{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"en/","text":"Here some tutorials and hints to build electronic drums. Most of the pad that can be found on the market don't give the same feeling as an acoustic drum, so we can convert an acoustic drum to e-drum using mesh heads and adding piezo sensors to connect to e-drum modules.","title":"Welcome"},{"location":"en/archlinux/","text":"Realtime Services","title":"Archlinux"},{"location":"en/archlinux/realtime/","text":"Documentation Realtime kernel Professional Audio Packages required: linux-rt or alternative realtime kernel Utilities QuickScan Linux configuration checker for systems to be used for real-time audio. Requires perl-tk package.","title":"Realtime kernel and low latency"},{"location":"en/archlinux/realtime/#documentation","text":"Realtime kernel Professional Audio","title":"Documentation"},{"location":"en/archlinux/realtime/#packages-required","text":"linux-rt or alternative realtime kernel","title":"Packages required:"},{"location":"en/archlinux/realtime/#utilities","text":"QuickScan Linux configuration checker for systems to be used for real-time audio. Requires perl-tk package.","title":"Utilities"},{"location":"en/archlinux/reaper-linux-windows-vst/","text":"Mingw-w64 - GCC for Windows 64 & 32 bits Required by Carla bridges, you can choose to install compiler and runtimes from AUR or from unofficial user repositories . I choosed the latter option. Wine Staging To run Windows applications I choosed wine-staging package. WineASIO - ASIO to JACK driver for Wine Install wineasio package from AUR. At the moment there could be a wineasio build problem because a missing unicode.h header in Wine, check in the link above to how to fix the issue. See also WineASIO and REAPER page at KXStudio website. Carla Install carla-git (or carla from official repositories, not tested). Install carla-bridges-win32-git and carla-bridges-win64-git . Launch Carla and click the plus button to add plug-ins. Using the search button, make sure that the Windows 32 and Windows 64 boxes are ticked, then scan for plug-ins. You may need to adjust the search path in Carla\u2019s settings. REAPER Install REAPER for Linux, I just made a local copy and integrated with the desktop environment using its install script. Add Carla as a plug-in and the Carla plug-in to load Windows VSTs: Select menu Options -> Preferences -> Plug-ins -> VST . Press Edit button and add /usr/lib/vst . Press Re-scan , Apply and OK buttons. You can now load Carla plugins from menu Insert -> Virtual instrument on new track... --> All Plugins --> VSTi Sources: https://appuals.com/how-to-use-windows-vsts-in-latest-reaper-5-93-linux-native-builds/ https://www.youtube.com/watch?v=PiaWozQ69eE","title":"How to Use Windows VSTs in REAPER Linux-Native builds (Archlinux)"},{"location":"en/archlinux/reaper-linux-windows-vst/#mingw-w64-gcc-for-windows-64-32-bits","text":"Required by Carla bridges, you can choose to install compiler and runtimes from AUR or from unofficial user repositories . I choosed the latter option.","title":"Mingw-w64 - GCC for Windows 64 &amp; 32 bits"},{"location":"en/archlinux/reaper-linux-windows-vst/#wine-staging","text":"To run Windows applications I choosed wine-staging package.","title":"Wine Staging"},{"location":"en/archlinux/reaper-linux-windows-vst/#wineasio-asio-to-jack-driver-for-wine","text":"Install wineasio package from AUR. At the moment there could be a wineasio build problem because a missing unicode.h header in Wine, check in the link above to how to fix the issue. See also WineASIO and REAPER page at KXStudio website.","title":"WineASIO - ASIO to JACK driver for Wine"},{"location":"en/archlinux/reaper-linux-windows-vst/#carla","text":"Install carla-git (or carla from official repositories, not tested). Install carla-bridges-win32-git and carla-bridges-win64-git . Launch Carla and click the plus button to add plug-ins. Using the search button, make sure that the Windows 32 and Windows 64 boxes are ticked, then scan for plug-ins. You may need to adjust the search path in Carla\u2019s settings.","title":"Carla"},{"location":"en/archlinux/reaper-linux-windows-vst/#reaper","text":"Install REAPER for Linux, I just made a local copy and integrated with the desktop environment using its install script. Add Carla as a plug-in and the Carla plug-in to load Windows VSTs: Select menu Options -> Preferences -> Plug-ins -> VST . Press Edit button and add /usr/lib/vst . Press Re-scan , Apply and OK buttons. You can now load Carla plugins from menu Insert -> Virtual instrument on new track... --> All Plugins --> VSTi Sources: https://appuals.com/how-to-use-windows-vsts-in-latest-reaper-5-93-linux-native-builds/ https://www.youtube.com/watch?v=PiaWozQ69eE","title":"REAPER"},{"location":"en/archlinux/services/","text":"Packages required: Official Archlinux Repository a2jmidid A daemon for exposing legacy ALSA sequencer applications in JACK MIDI system. opus Totally open, royalty-free, highly versatile audio codec (optional jack2 dependancy before build). netcat GNU rewrite of netcat, the network piping application (required to run LSCP presets from command line). jsampler LinuxSampler Java GUI (to create LSCP presets). AUR jack2-no-dbus-git Classic jack2 without dbus enabled. For starting as daemon with systemd. linuxsampler-svn Professional-grade audio sampler alternative to Gigasampler Template Services (in /usr/lib/systemd/system): a2jmidid@.service jack2-no-dbus@.service linuxsampler@.service Shell scripts and configuration files service.conf in /home/$USER/.config/jack/ service.sh in /home/$USER/.config/linuxsampler.org/ drums.lscp in /home/$USER/.config/linuxsampler.org/","title":"Jack2, A2jmidid and Linuxsampler systemd services on Archlinux"},{"location":"en/archlinux/services/#packages-required","text":"","title":"Packages required:"},{"location":"en/archlinux/services/#official-archlinux-repository","text":"a2jmidid A daemon for exposing legacy ALSA sequencer applications in JACK MIDI system. opus Totally open, royalty-free, highly versatile audio codec (optional jack2 dependancy before build). netcat GNU rewrite of netcat, the network piping application (required to run LSCP presets from command line). jsampler LinuxSampler Java GUI (to create LSCP presets).","title":"Official Archlinux Repository"},{"location":"en/archlinux/services/#aur","text":"jack2-no-dbus-git Classic jack2 without dbus enabled. For starting as daemon with systemd. linuxsampler-svn Professional-grade audio sampler alternative to Gigasampler","title":"AUR"},{"location":"en/archlinux/services/#template-services-in-usrlibsystemdsystem","text":"a2jmidid@.service jack2-no-dbus@.service linuxsampler@.service","title":"Template Services (in /usr/lib/systemd/system):"},{"location":"en/archlinux/services/#shell-scripts-and-configuration-files","text":"service.conf in /home/$USER/.config/jack/ service.sh in /home/$USER/.config/linuxsampler.org/ drums.lscp in /home/$USER/.config/linuxsampler.org/","title":"Shell scripts and configuration files"},{"location":"en/diy/cymbal_piezo/","text":"Material list Self adhesive waterproofing bitumen tape (with an aluminium or vinyl foil) 1 Ikea PANN\u00c5 place mat (diam. 37cm) made of EVA (various colors available) A good length of extra heavy duty double sided reinforced tape (cross woven construction) A short length of double-sided foam tape (I do prefere to do it myself using some double-sided reinforced tape and a piece of 1mm thick neoprene foam) 1 acoustic cymbal 1 to 3 or your favorite piezo transducer. 1 plastic box 1 to 2 jack sockets 0 to 2 home made Piezo/Piezo to Piezo/Switch adapter (cf. Keith Raper\u2019s circuit) Wire. Instructions 1 - Dampening the cymbal 1zone cymbal : Cover the back of the entire cymbal with bitumen tape and cut the unwanted part around the cymbal. Keep the bell free of bitumen tape. Cut a small disc from the bitumen tape in order to make a room for the main piezo. 2zone / 3zone cymbal : Same technique, but you have to let about 3cm from the edge of your cymbal free of bitumen tape. 2 - Preparing the covering Cut a disc in the centre of the place mat, the size of your bell, and a smaller one for your main piezo. Cut the unwanted part around the cymbal (if your cymbal is smaller than the covering material) 3 - Adding the electronics A picture is probably better than a long text \ud83d\ude09 2 Zone: 3 Zone: The main piezo (set on the bow) and the bell piezo must be fixed using double-sided foam tape (some like to use half a disc instead of a full disc under the piezo). The edge piezo can be set using the thinner double-sided reinforced tape. Hide the wires into the bitumen tape (cut a line). If you want to build a simple 1zone cymbal, just keep the main piezo and forget the other piezos and the PP to PS adapter circuit. 4 \u2013 Covering the all thing Put some double-sided reinforced tape on your bitumen tape, but don\u2019t remove the protection yet! Put a lot of it around the main piezo room (it will help the plastic box to stay in place later). Make all the electronic stuff pass thru the small hole and check for bumps on the surface to cover. Keep the covering stuff correctly placed on your cymbal and remove the tape protection little by little. 5 \u2013 Finishing Prepare the needed holes in the plastic box for the main piezo and jack sockets. Check them twice \ud83d\ude09 Use a piece of double-sided reinforced tape to fix the plastic box on the covering material (when I say extra heavy duty double-sided reinforced tape in the material list, I mean really heavy duty ^^). Secure the jack sockets and put the box cover. Put a small disc of bitumen tape over the visible piezo transducers (it will help to secure the solder points, and be a cool thing to \u201cchoke\u201d). 2Zone 3Zone 6 \u2013 Setting up your module 1Zone : Plug your trigger then set the sensitivity and main parameters. 2Zone : Use a dual Piezo/Switch capable input. Set the trigger type as you would do for a Piezo/Switch cymbal (CY-8 / PCY-65S, for exemple) Set the sensitivity and main parameters. If the the edge triggering is too sensitive, add a pot between the edge piezo and the PP to PS adapter, and adjust it. 3Zone : Use a dual Piezo/Switch input + a mono input (or a dual one) Plug the bow/edge output of the cymbal to the dual input. Plug the bell output to the mono input of your module. Set parameters for the bow/edge part as you would do with a 2Zone cymbal. If the the edge triggering is too sensitive, add a pot between the edge piezo and the PP to PS adapter, and adjust it. Set parameters for the bell part as you would do with a 1Zone cymbal, then set its threshold so your harder tip hits on the bow don\u2019t trigger the bell. 7 \u2013 Choke switch The edge piezo combined to the PP to PS adapter will act as a choke switch. Cherry on the cake \ud83d\ude42 8 \u2013 Some ideas to experiment with... If you own a Roland 3Zone ride input, you may add a additional PP to PS adapter between the bell piezo and the Bell jack socket (sleeve/ring). Don\u2019t forget to link the main piezo to the tip/sleeve couple of this same socket. You\u2019ll get the needed Bow/Edge and Bow/Bell output this way. NOTE: Polarity is inverted on Roland main piezo [//]: # Or a simple alternative: [//]: # If you want to use a Yamaha 3Zone input, you may use 1 single jack socket. Firstly mount the 2Zone electronic part then add a PP to PS adapter AND a 10k resistor between the bell piezo (+) and the ring of the single jack socket. You may build such a cymbal from a practice cymbal and use another place mat as your playing surface. The original post is available on the Toontrack website . There is an article on this topic in the april issue of DigitalDrummer magazine .","title":"2Z/3Z Choke Capable Cymbal (by PFozz)"},{"location":"en/diy/cymbal_piezo/#material-list","text":"Self adhesive waterproofing bitumen tape (with an aluminium or vinyl foil) 1 Ikea PANN\u00c5 place mat (diam. 37cm) made of EVA (various colors available) A good length of extra heavy duty double sided reinforced tape (cross woven construction) A short length of double-sided foam tape (I do prefere to do it myself using some double-sided reinforced tape and a piece of 1mm thick neoprene foam) 1 acoustic cymbal 1 to 3 or your favorite piezo transducer. 1 plastic box 1 to 2 jack sockets 0 to 2 home made Piezo/Piezo to Piezo/Switch adapter (cf. Keith Raper\u2019s circuit) Wire.","title":"Material list"},{"location":"en/diy/cymbal_piezo/#instructions","text":"","title":"Instructions"},{"location":"en/diy/cymbal_piezo/#1-dampening-the-cymbal","text":"1zone cymbal : Cover the back of the entire cymbal with bitumen tape and cut the unwanted part around the cymbal. Keep the bell free of bitumen tape. Cut a small disc from the bitumen tape in order to make a room for the main piezo. 2zone / 3zone cymbal : Same technique, but you have to let about 3cm from the edge of your cymbal free of bitumen tape.","title":"1 - Dampening the cymbal"},{"location":"en/diy/cymbal_piezo/#2-preparing-the-covering","text":"Cut a disc in the centre of the place mat, the size of your bell, and a smaller one for your main piezo. Cut the unwanted part around the cymbal (if your cymbal is smaller than the covering material)","title":"2 - Preparing the covering"},{"location":"en/diy/cymbal_piezo/#3-adding-the-electronics","text":"A picture is probably better than a long text \ud83d\ude09 2 Zone: 3 Zone: The main piezo (set on the bow) and the bell piezo must be fixed using double-sided foam tape (some like to use half a disc instead of a full disc under the piezo). The edge piezo can be set using the thinner double-sided reinforced tape. Hide the wires into the bitumen tape (cut a line). If you want to build a simple 1zone cymbal, just keep the main piezo and forget the other piezos and the PP to PS adapter circuit.","title":"3 - Adding the electronics"},{"location":"en/diy/cymbal_piezo/#4-covering-the-all-thing","text":"Put some double-sided reinforced tape on your bitumen tape, but don\u2019t remove the protection yet! Put a lot of it around the main piezo room (it will help the plastic box to stay in place later). Make all the electronic stuff pass thru the small hole and check for bumps on the surface to cover. Keep the covering stuff correctly placed on your cymbal and remove the tape protection little by little.","title":"4 \u2013 Covering the all thing"},{"location":"en/diy/cymbal_piezo/#5-finishing","text":"Prepare the needed holes in the plastic box for the main piezo and jack sockets. Check them twice \ud83d\ude09 Use a piece of double-sided reinforced tape to fix the plastic box on the covering material (when I say extra heavy duty double-sided reinforced tape in the material list, I mean really heavy duty ^^). Secure the jack sockets and put the box cover. Put a small disc of bitumen tape over the visible piezo transducers (it will help to secure the solder points, and be a cool thing to \u201cchoke\u201d). 2Zone 3Zone","title":"5 \u2013 Finishing"},{"location":"en/diy/cymbal_piezo/#6-setting-up-your-module","text":"1Zone : Plug your trigger then set the sensitivity and main parameters. 2Zone : Use a dual Piezo/Switch capable input. Set the trigger type as you would do for a Piezo/Switch cymbal (CY-8 / PCY-65S, for exemple) Set the sensitivity and main parameters. If the the edge triggering is too sensitive, add a pot between the edge piezo and the PP to PS adapter, and adjust it. 3Zone : Use a dual Piezo/Switch input + a mono input (or a dual one) Plug the bow/edge output of the cymbal to the dual input. Plug the bell output to the mono input of your module. Set parameters for the bow/edge part as you would do with a 2Zone cymbal. If the the edge triggering is too sensitive, add a pot between the edge piezo and the PP to PS adapter, and adjust it. Set parameters for the bell part as you would do with a 1Zone cymbal, then set its threshold so your harder tip hits on the bow don\u2019t trigger the bell.","title":"6 \u2013 Setting up your module"},{"location":"en/diy/cymbal_piezo/#7-choke-switch","text":"The edge piezo combined to the PP to PS adapter will act as a choke switch. Cherry on the cake \ud83d\ude42","title":"7 \u2013 Choke switch"},{"location":"en/diy/cymbal_piezo/#8-some-ideas-to-experiment-with","text":"If you own a Roland 3Zone ride input, you may add a additional PP to PS adapter between the bell piezo and the Bell jack socket (sleeve/ring). Don\u2019t forget to link the main piezo to the tip/sleeve couple of this same socket. You\u2019ll get the needed Bow/Edge and Bow/Bell output this way. NOTE: Polarity is inverted on Roland main piezo [//]: # Or a simple alternative: [//]: # If you want to use a Yamaha 3Zone input, you may use 1 single jack socket. Firstly mount the 2Zone electronic part then add a PP to PS adapter AND a 10k resistor between the bell piezo (+) and the ring of the single jack socket. You may build such a cymbal from a practice cymbal and use another place mat as your playing surface. The original post is available on the Toontrack website . There is an article on this topic in the april issue of DigitalDrummer magazine .","title":"8 \u2013 Some ideas to experiment with..."},{"location":"en/diy/cymbal_switch/","text":"Modifying an acoustic cymbal or a rubber practice cymbal pad like Peace or Stagg Getting Myrc Instrument's membrane trigger switches: Edge and Bell Wiring of a Yamaha 3 zones cymbal From VDrums.com forum","title":"Cymbal (2 and 3 Zones) using switches"},{"location":"en/diy/hihat/","text":"Using a Force Sensing Resistor (FSR) sensor solution: From VDrums Forum : Your browser does not support HTML5 video. Your browser does not support HTML5 video.","title":"DIY HiHat"},{"location":"en/diy/keith_pp_2_ps/","text":"DON'T MISS THE UPDATED INFO BELOW THE ORIGINAL CONTENT \ud83d\ude09 The information provided here is freely available to all for NON-COMMERCIAL purposes only. The schematics and information are provided 'as is', without warranty of any kind. As everything provided on this website, the author (Keith Raper), EDrum For Free or any other party cannot be held responsible for any damages to yourself, others, or equipment while attempting any of the projects listed on these pages. Please use common sense. Many of you and mostly members of the DTXPress Yahoo! group have heard about the \"Magic Box\" which will allow two pads to use one input on the DTXpress, and also combine two piezos from a single pad into a single piezo and rim switch signal for use on the DTXpress (some non Yamaha dual zone pads use two piezos instead of a single piezo and a rim switch). As the original \"Magic Box\" was quite complex, I have come up with a simplified idea which should be within the abilities of anyone who wants to have a go. The components will only cost a few cents and the circuit is \"passive\" in that it does not use any external power (but has an \"active\" component). Here are some schematics for various applications: NB : Bear in mind that when combining two pads into one input you can only get one sound at a time (although you can get both if one hit is slightly after the other) so you need to choose your combinations with some thought (ie don't combine the kick drum, snare or high-hat with anything). Example applications : Mesh Head dual-trigger (piezo/piezo) to piezo/switch input (Dual mesh toms on the TD-8/TD-6V/DTXPress/...). Dual-zone cymbal made of 2 piezos (design by PFozz to come). Triple-zone cymbal made of 3 piezos (design by PFozz to come). ... For less \"rim/edge sensitivity\", reduce the R2 value but DON'T replace it with a wire (100K to 1M is alright). UPDATED (03/2006) I have now made a PCB and am building up my DTXpander (for a small fee) for people who cannot do it themselves. I am still happy for people to build their own, and here's the latest circuit: http://edrum.for.free.fr/static/pictures/KeithRDTXpanderCheapB.pdf The changes are minor : putting a potentiometer for R1 to adjust sensitivity Schottky diodes to reduce the voltage drop from the piezos (0.3V instead of 0.7V) a jumper to allow one of the diodes to be shorted out. These changes may help with systems not like my commercial DTXpress kit. The Schottky diodes will help if the piezo signals are low. I have not noticed any difference with the DTXpress. The option to bypass one of the diodes can help improve the signal from that pad if the polarity is wrong on the pad - the circuit works best with positive going pulses from the piezo. Enjoy \ud83d\ude09 Keith Raper (Key Design Electronics Ltd.) http://www.kdel.co.uk Source: ToonTrack Forum There is an article on this topic in the october issue of DigitalDrummer magazine .","title":"Piezo/Piezo to Piezo/Switch Adaptor by Keith Raper"},{"location":"en/diy/keith_pp_2_ps/#updated-032006","text":"I have now made a PCB and am building up my DTXpander (for a small fee) for people who cannot do it themselves. I am still happy for people to build their own, and here's the latest circuit: http://edrum.for.free.fr/static/pictures/KeithRDTXpanderCheapB.pdf The changes are minor : putting a potentiometer for R1 to adjust sensitivity Schottky diodes to reduce the voltage drop from the piezos (0.3V instead of 0.7V) a jumper to allow one of the diodes to be shorted out. These changes may help with systems not like my commercial DTXpress kit. The Schottky diodes will help if the piezo signals are low. I have not noticed any difference with the DTXpress. The option to bypass one of the diodes can help improve the signal from that pad if the polarity is wrong on the pad - the circuit works best with positive going pulses from the piezo. Enjoy \ud83d\ude09 Keith Raper (Key Design Electronics Ltd.) http://www.kdel.co.uk Source: ToonTrack Forum There is an article on this topic in the october issue of DigitalDrummer magazine .","title":"UPDATED (03/2006)"},{"location":"en/diy/mesh_heads/","text":"Buy a pet screen or mosquito net: Prepare using a annealed (soft) copper ring: Sew the net on the copper ring: Source: Instructables website","title":"DIY Mesh Heads"},{"location":"en/diy/octobans/","text":"6\" (150mm) ventilation plastic tube:","title":"E-Octobans"},{"location":"en/diy/piezo_wiring/","text":"","title":"Piezo Wiring"},{"location":"en/diy/sensor_cushion/","text":"Pic #1: Shows the complete jig with axis pin in place. Two 1 1/2\" x 1/8\" pieces of aluminum screwed to a 2 1/4\" wide x 1 3/8\" thick piece of wood. I use a table saw to rip a 2x4 down to 1 3/8\" but you could stack various thicknesses to equal 1 3/8\". You can make the thickness equal to whatever your foam is. I also made one for Roto-toms that is only 1\" thick...all other measurements remain the same. I am using a 1 3/4\" \"T\" pin...a 2\" pin would work better I think. Pic #2: Using the smallest bit I have I drilled a hole in the bottom piece in the center (3/4\" from each side) and a hole in the top piece 1/8\" from one side trying to keep the same measurement from each end. I secure the bottom piece of aluminum first then using a square block of the 1 3/8\" wood as a guide I secure the top piece. It is important that the holes are lined up square and plumb with each other. The edges of the aluminum should be flush with the wood on either side. The two lines on the bottom piece are used to line-up the foam blank and keep the center over the hole. Clamp the jig to your work bench. Pic #3: I use one square of 3/8\" Supersoft Poron foam (adhesive backed) sandwiched between two squares of 1/2\" foam. I calculated each layer's maximum dimension and made strips to mark the back of the Poron sheets in squares that I cut with my electric carving/filet knife. The left measurements are the proper dimension for each layer...the right denotes each layer's thickness. I then stack the layers ala Jman's Castles using the adhesive but do not remove the bottom layer's paper (use that adhesive to adhere to your piezo). Alternating the layers will help to center them. I used to cut circles but found this easier although a little more wasteful. Pic #4: The blank is ready for the knife. Using the marks center the blank and push the pin in from the bottom as square as you can...this is tricky but if you miss the top hole just pull the pin away from the top piece slightly and poke it just above the foam's surface and slide it back into position. A small block of wood glued to the underside next to the hole might aid this step. If I find a longer pin I plan to glue a guide block with a small hole there. The top of the pin should only protrude slighly above the top or the knife will hit it. The closer to the axis you get the better your cones will look. If you are off the cone will be somewhat angled...not a big deal really IMO. Pic #5: Using an electric knife (you can use fine tooth manual saw or knife) I start to cut holding the blade against the jig...once the blade gets to the axis gently turn the cone by hand towards the blade. Be carefull not to distort the cone as you turn. I cut in small passes until I get the shape right spinning the cone and trimming. With the cone still in the jig, I then use 50 grit sandpaper and buff the sides but that sep is not critical. I use an exacto knife to cut the slot in the bottom of the cone for the wires but I have heard of people using a hot soldering iron. I also filed the top piece of aluminum at an angle to allow the knife better contact with the foam...if you don't the cone will be slightly larger than 1/4\" at the top...no bigggie IMO. It's important to know that I am a \"lefty\" and this jig is designed for \"lefties\" only. If you \"righties\" can't figure it out then too bad.","title":"Sensor Cushion"},{"location":"en/diy/splash/","text":"Buy a sanding disc pad: Use mastic / glue to fix a piezo and connect it to a female mini-jack plug:","title":"E-Splash"},{"location":"en/linuxsampler/","text":"Docs SFZ","title":"LinuxSampler"},{"location":"en/linuxsampler/docs/","text":"table.goverview { margin-left:auto; margin-right:auto; } .goverview td { display:inline-block; vertical-align:bottom; border: 0; } .goverview td img { margin-left:auto; margin-right:auto; display:block; max-height:130px; } .goverview td p { display:inline-block; clear:both; text-align:center; width:100%; } This site offers various documentation, manuals and articles about applications and sofware components of the LinuxSampler project. Gigedit Instrument Editor SFZ File Format Instrument Scripts NOTE This documentation site is currently in a transition phase. Most of the old manuals and documents of the LinuxSampler project will be moved to this site. However this process has not been completed yet. You may want to refer to some of the old documentation in the meantime.","title":"Linuxsampler Documents and Manuals"},{"location":"en/linuxsampler/docs/gigedit/","text":"Gigedit is a graphical instrument editor for sample based virtual instruments, based on the GigaStudio/Gigasampler file format. The GigaStudio/Gigasampler (.gig) file format is one of the major sampler formats supported by LinuxSampler and hence you can use Gigedit both as stand-alone instrument editor, or in conjunction with LinuxSampler for editing such instruments \"live\" while playing them with the sampler. This documentation is currently in a transition phase. The old Gigedit manual will move to this location, however this process has not been completed yet. You may want to refer to the old Gigedit manual in the meantime. So far, the only topic covered by this new manual is managing real-time instrument scripts with Gigedit. \u2191 LinuxSampler Documents \u2192 Managing Scripts","title":"Gigedit"},{"location":"en/linuxsampler/docs/gigedit/scripts/","text":"Gigedit and LinuxSampler provide support for so called real-time instrument scripts . You can use such scripts to add your own software extensions to the sampler, in order to customize and/or extend the sampler's software behaviors and features, specifically to satisfy particular software features required for some of your sounds. This article describes how to manage instrument scripts with Gigedit, that is how to add scripts to your GigaStudio files and how to apply them to your sounds. If you rather want to find out more about instrument scripts in general or learn about the details of this programming language, then please refer to the Real-Time instrument Scripts manual . Instrument scripts is a feature extension of the GigaStudio file format which is only available with Gigedit and LinuxSampler. Instrument scripts are not supported by the original GigaStudio software. Adding Scripts Before you can apply scripts to some of your sounds, you first need to add the instrument script to your GigaStudio file. Once you added a script to your GigaStudio file, the script can then be assigned to one or several instruments of that GigaStudio file. To add a new instrument script to your GigaStudio file, click on the \"Scripts\" tab, then right click on the script list view and select \"Add Script\". A new empty script has now been added to your GigaStudio file. Like with instruments and samples you may now click twice on the new script in the script list and rename the script to something meaningful. Editing Scripts The new script is yet empty. To add some code to the script, or to modify an existing script, select the respective script name in the list view, then right click on that script name and select \"Edit Script\". The script editor has now appeared on your screen. Enter or edit the code for the script with your keyboard. Once you are done, click on \"Apply\". Close the script editor and select \"Save\" from the menu to save your GigaStudio file with your new script. NKSP Instrument Script Editor To learn the NKSP script language in order to write or customize such scripts, please refer to the NKSP Language Manual . Assigning Scripts to Instruments Like with samples, scripts are stored on a global level in GigaStudio files and are shared by all instruments of that GigaStudio file. That means you may assign a script to several of your instruments, which are only storing a reference to that script. If you later on change the script code, all instruments will automatically have that updated script. To assign a script to one of your instruments, select the \"Instruments\" tab, then select the name of the instrument in the instrument list view, then right click on the instrument name and select \"Script Slots...\". A new window appeared (like below), showing you all scripts currently assigned to that particular instrument. Now select the \"Scripts\" tab on the main window and drag the script you want to assign to your instrument from the script list view to the center of the script slots window. The script slots window now updated and shows you a new row with the name of the script that you just added. Script 'Aftertouch Trigger' assigned to the instrument 'Performance Orchestra'. Close the script slots window and select \"Save\" from the menu to make your script assignment persistent to your GigaStudio file. Even though Gigedit allows you to assign more than one script to an instrument, this is not yet supported by LinuxSampler. If you load an instrument with multiple script slots into LinuxSampler, then LinuxSampler will currently only load the instrument's first script slot and show you a warning on the console that it ignores all other scripts assigned to that instrument. This will change in future. \u2191 Gigedit","title":"Managing Scripts"},{"location":"en/linuxsampler/docs/gigedit/scripts/#adding-scripts","text":"Before you can apply scripts to some of your sounds, you first need to add the instrument script to your GigaStudio file. Once you added a script to your GigaStudio file, the script can then be assigned to one or several instruments of that GigaStudio file. To add a new instrument script to your GigaStudio file, click on the \"Scripts\" tab, then right click on the script list view and select \"Add Script\". A new empty script has now been added to your GigaStudio file. Like with instruments and samples you may now click twice on the new script in the script list and rename the script to something meaningful.","title":"Adding Scripts"},{"location":"en/linuxsampler/docs/gigedit/scripts/#editing-scripts","text":"The new script is yet empty. To add some code to the script, or to modify an existing script, select the respective script name in the list view, then right click on that script name and select \"Edit Script\". The script editor has now appeared on your screen. Enter or edit the code for the script with your keyboard. Once you are done, click on \"Apply\". Close the script editor and select \"Save\" from the menu to save your GigaStudio file with your new script. NKSP Instrument Script Editor To learn the NKSP script language in order to write or customize such scripts, please refer to the NKSP Language Manual .","title":"Editing Scripts"},{"location":"en/linuxsampler/docs/gigedit/scripts/#assigning-scripts-to-instruments","text":"Like with samples, scripts are stored on a global level in GigaStudio files and are shared by all instruments of that GigaStudio file. That means you may assign a script to several of your instruments, which are only storing a reference to that script. If you later on change the script code, all instruments will automatically have that updated script. To assign a script to one of your instruments, select the \"Instruments\" tab, then select the name of the instrument in the instrument list view, then right click on the instrument name and select \"Script Slots...\". A new window appeared (like below), showing you all scripts currently assigned to that particular instrument. Now select the \"Scripts\" tab on the main window and drag the script you want to assign to your instrument from the script list view to the center of the script slots window. The script slots window now updated and shows you a new row with the name of the script that you just added. Script 'Aftertouch Trigger' assigned to the instrument 'Performance Orchestra'. Close the script slots window and select \"Save\" from the menu to make your script assignment persistent to your GigaStudio file. Even though Gigedit allows you to assign more than one script to an instrument, this is not yet supported by LinuxSampler. If you load an instrument with multiple script slots into LinuxSampler, then LinuxSampler will currently only load the instrument's first script slot and show you a warning on the console that it ignores all other scripts assigned to that instrument. This will change in future. \u2191 Gigedit","title":"Assigning Scripts to Instruments"},{"location":"en/linuxsampler/docs/nksp/","text":"The sampler technology is constantly evolving to satisfy new feature requirements of sound designer in order to allow them creating more and more realistic sounds. As an example you might look at state of the art orchestra libraries. They not only allow you pick one of the individual instrument sounds of an orchestra, they also allow you to control the articulation of the respective orchestra instrument while playing them live with your keyboard. So you might start playing an interesting intro with a string ensemble in spiccato playing style, then you might go over into a slow bridge part where the string ensemble is resembling a legato articulation or even portamento in between, which makes that part of the song very calm and relaxed, and then you shock your audience all of a sudden with a loud staccato , automatically supported by kettledrum and brass sounds, that wakes up even the last one in the back row. And the best thing: you did not switch to another instrument during that entire song. Technical Challenge Adding these kinds of features to a sampler had long been a challenge for software developers. On one hand you need to provide the musician additional controls to let him switch between such kind of orchestra articulations. Sound designers came up with various ideas to let the keyboard player do this. For example by using continous controllers like the keyboard's modulation wheel using a dedicated keys section on the keyboard where each key selects another playing style utilizing aftertouch support of keyboards and some more. And on the other hand developers needed to extend the sampler software and the instrument file format to deal with all those extensions. Thinking about portamento for example, the sampler not only has to pick the right sample for the first key the keyboard player hits, the sampler also has to detect the next note and needs to pick a special dedicated portamento sample that goes specifically from that one note to that other note. If the sampler would do that synthetically instead, then it would sound synthetically. And if that was not enough, sound designers started even to ask for very exotic features, specifically for just a bunch of sounds or even for just one single sound of theirs, for example a specific note pattern that shall automatically be added by the sampler to each note being played by the keyboard player. The requested feature set became such large, that sampler developers failed to put all this into their stock sampler software package. A completely new solution was required. Scripts as Solution Instead of bloating the sampler engine with more and more suboptimal features that not really suited anybody, the sampler developers turned the way around and opened the sampler engine for sound designers, so that they could add their own custom software components and bundle them with their sounds. These kinds of software plugins that are directly glued and shipped with sounds are called Instrument Scripts , they extend the sampler software with new software features required by the respective sound. Sound designers were finally free to add their own features to the sampler and used Instrument Scripts extensively to create stunning new sounds. For example they came up with a feature called symphatetic resonance for their piano sound libraries, which brought piano sounds another great leap forward to match their real, physical counter parts. Using Scripts with LinuxSampler LinuxSampler allows you to write and use such Instrument Scripts as well. At the moment support for instrument scripts is provided by the GigaStudio format engine, as well as now also by the SFZ format engine of LinuxSampler. The script engine was developed in a very modular design, where most of the script engine's software is independent from the actual sampler format and the respective sampler format engine is just adding its format specific extensions to the script language. For example the GigaStudio format engine adds scripting functions to allow the sound designer to control the dimension region by scripts. Bundling Scripts with GigaStudio (.gig) Files Our graphical instrument editor for the GigaStudio format - gigedit - includes an instrument script editor and allows you to attach instrument scripts to individual GigaStudio format sounds. Refer to the gigedit manual for how to manage instrument scripts with gigedit . Bundling Scripts with SFZ (.sfz) Files LinuxSampler adds a new opcode script as an extension to the offical SFZ format. Similar to the sample opcode, a file system path needs to be assigned to the actual script file that should be loaded by the sampler. The script opcode should be placed in the SFZ file's < global > section. However at the moment the precise location of the opcode will simply be ignored by LinuxSampler. A simple example SFZ file may look like this: // real-time instrument scripts should be loaded in global section < global > script =path/to/my_nksp_script.txt // just load one audio file and assign in to entire key range < group > sample =some_sound.wav At the moment LinuxSampler supports only one script file per instrument. Accordingly there should only be one script opcode occurrence in your SFZ file. If you place more than one script opcode to a SFZ file, then only the first script will be loaded and the sampler will print a warning. In future this will change, and the sampler will support running multiple scripts, and will run the scripts subsequently on events according to the order the scripts appeared in the SFZ file. Learning the Script Language You certainly find some instrument scripts ready to be used on the Internet. So you can simply download and attach them to your sounds with gigedit . In order to write your own custom instrument scripts though, you need to get in touch with the scripting language. Refer to the NKSP Language Tour for learning how to write your own scripts. Script Language Reference If you are already familiar with the instrument script language basics, and just need details and examples to the individual built-in functions and built-in variables, then refer to the NKSP Reference Manual . \u2191 LinuxSampler Documents \u2192 NKSP Language","title":"Real-Time Instrument Scripts"},{"location":"en/linuxsampler/docs/nksp/#technical-challenge","text":"Adding these kinds of features to a sampler had long been a challenge for software developers. On one hand you need to provide the musician additional controls to let him switch between such kind of orchestra articulations. Sound designers came up with various ideas to let the keyboard player do this. For example by using continous controllers like the keyboard's modulation wheel using a dedicated keys section on the keyboard where each key selects another playing style utilizing aftertouch support of keyboards and some more. And on the other hand developers needed to extend the sampler software and the instrument file format to deal with all those extensions. Thinking about portamento for example, the sampler not only has to pick the right sample for the first key the keyboard player hits, the sampler also has to detect the next note and needs to pick a special dedicated portamento sample that goes specifically from that one note to that other note. If the sampler would do that synthetically instead, then it would sound synthetically. And if that was not enough, sound designers started even to ask for very exotic features, specifically for just a bunch of sounds or even for just one single sound of theirs, for example a specific note pattern that shall automatically be added by the sampler to each note being played by the keyboard player. The requested feature set became such large, that sampler developers failed to put all this into their stock sampler software package. A completely new solution was required.","title":"Technical Challenge"},{"location":"en/linuxsampler/docs/nksp/#scripts-as-solution","text":"Instead of bloating the sampler engine with more and more suboptimal features that not really suited anybody, the sampler developers turned the way around and opened the sampler engine for sound designers, so that they could add their own custom software components and bundle them with their sounds. These kinds of software plugins that are directly glued and shipped with sounds are called Instrument Scripts , they extend the sampler software with new software features required by the respective sound. Sound designers were finally free to add their own features to the sampler and used Instrument Scripts extensively to create stunning new sounds. For example they came up with a feature called symphatetic resonance for their piano sound libraries, which brought piano sounds another great leap forward to match their real, physical counter parts.","title":"Scripts as Solution"},{"location":"en/linuxsampler/docs/nksp/#using-scripts-with-linuxsampler","text":"LinuxSampler allows you to write and use such Instrument Scripts as well. At the moment support for instrument scripts is provided by the GigaStudio format engine, as well as now also by the SFZ format engine of LinuxSampler. The script engine was developed in a very modular design, where most of the script engine's software is independent from the actual sampler format and the respective sampler format engine is just adding its format specific extensions to the script language. For example the GigaStudio format engine adds scripting functions to allow the sound designer to control the dimension region by scripts.","title":"Using Scripts with LinuxSampler"},{"location":"en/linuxsampler/docs/nksp/#bundling-scripts-with-gigastudio-gig-files","text":"Our graphical instrument editor for the GigaStudio format - gigedit - includes an instrument script editor and allows you to attach instrument scripts to individual GigaStudio format sounds. Refer to the gigedit manual for how to manage instrument scripts with gigedit .","title":"Bundling Scripts with GigaStudio (.gig) Files"},{"location":"en/linuxsampler/docs/nksp/#bundling-scripts-with-sfz-sfz-files","text":"LinuxSampler adds a new opcode script as an extension to the offical SFZ format. Similar to the sample opcode, a file system path needs to be assigned to the actual script file that should be loaded by the sampler. The script opcode should be placed in the SFZ file's < global > section. However at the moment the precise location of the opcode will simply be ignored by LinuxSampler. A simple example SFZ file may look like this: // real-time instrument scripts should be loaded in global section < global > script =path/to/my_nksp_script.txt // just load one audio file and assign in to entire key range < group > sample =some_sound.wav At the moment LinuxSampler supports only one script file per instrument. Accordingly there should only be one script opcode occurrence in your SFZ file. If you place more than one script opcode to a SFZ file, then only the first script will be loaded and the sampler will print a warning. In future this will change, and the sampler will support running multiple scripts, and will run the scripts subsequently on events according to the order the scripts appeared in the SFZ file.","title":"Bundling Scripts with SFZ (.sfz) Files"},{"location":"en/linuxsampler/docs/nksp/#learning-the-script-language","text":"You certainly find some instrument scripts ready to be used on the Internet. So you can simply download and attach them to your sounds with gigedit . In order to write your own custom instrument scripts though, you need to get in touch with the scripting language. Refer to the NKSP Language Tour for learning how to write your own scripts.","title":"Learning the Script Language"},{"location":"en/linuxsampler/docs/nksp/#script-language-reference","text":"If you are already familiar with the instrument script language basics, and just need details and examples to the individual built-in functions and built-in variables, then refer to the NKSP Reference Manual . \u2191 LinuxSampler Documents \u2192 NKSP Language","title":"Script Language Reference"},{"location":"en/linuxsampler/docs/nksp/language/","text":"This document intends to give you a compact introduction and overview to the NKSP real-time instrument script language, so you can start writing your own instrument scripts in short time. It concentrates on describing the script language. If you rather want to learn how to modify and attach scripts to your sounds, then please refer to the gigedit manual for how to manage instrument scripts with gigedit for Gigasampler/GigaStudio format sounds, or refer to the SFZ opcode script for attaching NKSP scripts with SFZ format sounds. At a Glance NKSP stands for \"is N ot KSP \", which denotes its distinction to an existing proprietary language called KSP. NSKP is a script language specifically designed to write real-time capable software extensions to LinuxSampler's sampler engines that can be bundled individually with sounds by sound designers themselves. Instead of defining a completely new script language, NKSP is leaned on that mentioned properiatary script language. The biggest advantage is that sound designers and musicians can leverage the huge amount of existing KSP scripts which are already available for various purposes on the Internet, instead of being forced to write all scripts from scratch in a completely different language. That also means however that there are some differences between those two languages. Some extensions have been added to the NKSP core language to make it a bit more convenient and less error prone to write scripts, and various new functions had to be added due to the large difference of the sampler engines and their underlying sampler format. Efforts have been made though to make NKSP as much compatible to KSP as possible. The NKSP documentation will emphasize individual differences in the two languages and function implementations wherever they may occur, to give you immediate hints where you need to take care of regarding compatibility issues when writing scripts that should be spawned on both platforms. Please note that the current focus of NKSP is the sound controlling aspect of sounds. At this point there is no support for the graphical user interface function set of KSP in NKSP. Event Handlers NKSP is an event-driven language. That means you are writing so called event handlers which define what the sampler shall do on individual events that occur, while using the sound the script was bundled with. An event handler in general looks like this: on event-name statements end on There are currently four events available: Event Type Description on note This event handler is executed when a new note was triggered, i.e. when hitting a key on a MIDI keyboard. on release This event handler is executed when a new note was released, i.e. when releasing a key on a MIDI keyboard. on controller This event handler is executed when a MIDI control change event occurred. For instance when turning the modulation wheel at a MIDI keyboard. on init Executed only once, as very first event handler, right after the script had been loaded. This code block is usually used to initialize variables in your script with some initial, useful data. You are free to decide for which ones of those event types you are going to write an event handler for. You can write an event handler for only one event type or write event handlers for all of those event types. Also dependent on the respective event type, there are certain things you can do and things which you can't do. But more on that later. Note Events As a first example, the following tiny script will print a message to your terminal whenever you trigger a new note with your MIDI keyboard. on note message ( \"A new note was triggered!\" ) end on Probably you are also interested to see which note you triggered exactly. The sampler provides you a so called built-in variable called $EVENT_NOTE which reflects the note number (as value between 0 and 127) of the note that has just been triggered. Additionally the built-in variable $EVENT_VELOCITY provides you the velocity value (also between 0 and 127) of the note event. on note message ( \"Note \" & $EVENT_NOTE & \" was triggered with velocity \" & $EVENT_VELOCITY ) end on The & character concatenates text strings with each other. In this case it is also automatically converting the note number into a text string. The message() function is not appropriate for being used with your final production sounds, since it can lead to audio dropouts. You should only use the message() function to try out things, and to spot and debug problems with your scripts. Release Events As counter part to the note event handler, there is also the release event handler, which is executed when a note was released. This event handler can be used similarly: on release message ( \"Note \" & $EVENT_NOTE & \" was triggered with velocity \" & $EVENT_VELOCITY ) end on Please note that you can hardly find MIDI keyboards which support release velocity. So with most keyboards this value will be 127. Controller Events Now let's extend the first script to not only show note-on and note-off events, but also to show a message whenever you use a MIDI controller (i.e. modulation wheel, sustain pedal, etc.). on note message ( \"Note \" & $EVENT_NOTE & \" was triggered with velocity \" & $EVENT_VELOCITY ) end on on release message ( \"Note \" & $EVENT_NOTE & \" was triggered with velocity \" & $EVENT_VELOCITY ) end on on controller message ( \"MIDI Controller \" & $CC_NUM & \" changed its value to \" & $CC[$CC_NUM] ) end on It looks very similar to the note event handlers. $CC_NUM reflects the MIDI controller number of the MIDI controller that had been changed and %CC is a so called array variable, which not only contains a single number value, but instead it contains several values at the same time. The built-in %CC array variable contains the current controller values of all 127 MIDI controllers. So %CC[1] for example would give you the current controller value of the modulation wheel, and therefore %CC[$CC_NUM] reflects the new controller value of the controller that just had been changed. There is some special aspect you need to be aware about: in contrast to the MIDI standard, monophonic aftertouch (a.k.a. channel pressure) and pitch beend wheel are handled by NKSP as if they were regular MIDI controllers. So a value change of one of those two triggers a regular controller event handler to be executed. To obtain the current aftertouch value you can use %CC[$VCC_MONO_AT] , and to get the current pitch bend wheel value use %CC[$VCC_PITCH_BEND] . Script Load Event As the last one of the four event types available with NKSP, the following is an example of an init event handler. on init message ( \"This script has been loaded and is ready now!\" ) end on You might think, that this is probably a very exotic event. Because in fact, this \"event\" is only executed once for your script: exactly when the script was loaded by the sampler. This is not an unimportant event handler though. Because it is used to prepare your script for various purposes. We will get more about that later. Comments Let's face it: software code is sometimes hard to read, especially when you are not a professional software developer who deals with such kinds of things every day. To make it more easy for you to understand, what you had in mind when you wrote a certain script three years ago, and also if some other developer might need to continue working on your scripts one day, you should place as many comments into your scripts as possible. A comment in NKSP is everything that is nested into a an opening and closing pair of curly braces. { This is a comment. } You cannot only use this to leave some human readable explanations here and there, you might also use such curly braces to quickly disable parts of your scripts for a moment, i.e. when debugging certain things. on init { The following will be prompted to the terminal when the sampler loaded this script. } message ( \"My script loaded.\" ) { This code block is commented out, so these two messages will not be displayed } { message(\"Another text\") message(\"And another one\") } end on What Next? You have completed the introduction of the NKSP real-time instrument script language at this point. You can now dive into the details of the NKSP language by moving on to the NKSP reference documentation which provides you an overview and quick access to the details of all built-in functions, built-in variables and more. \u2191 Instrument Scripts \u2192 NKSP Reference","title":"NKSP Language"},{"location":"en/linuxsampler/docs/nksp/language/#at-a-glance","text":"NKSP stands for \"is N ot KSP \", which denotes its distinction to an existing proprietary language called KSP. NSKP is a script language specifically designed to write real-time capable software extensions to LinuxSampler's sampler engines that can be bundled individually with sounds by sound designers themselves. Instead of defining a completely new script language, NKSP is leaned on that mentioned properiatary script language. The biggest advantage is that sound designers and musicians can leverage the huge amount of existing KSP scripts which are already available for various purposes on the Internet, instead of being forced to write all scripts from scratch in a completely different language. That also means however that there are some differences between those two languages. Some extensions have been added to the NKSP core language to make it a bit more convenient and less error prone to write scripts, and various new functions had to be added due to the large difference of the sampler engines and their underlying sampler format. Efforts have been made though to make NKSP as much compatible to KSP as possible. The NKSP documentation will emphasize individual differences in the two languages and function implementations wherever they may occur, to give you immediate hints where you need to take care of regarding compatibility issues when writing scripts that should be spawned on both platforms. Please note that the current focus of NKSP is the sound controlling aspect of sounds. At this point there is no support for the graphical user interface function set of KSP in NKSP.","title":"At a Glance"},{"location":"en/linuxsampler/docs/nksp/language/#event-handlers","text":"NKSP is an event-driven language. That means you are writing so called event handlers which define what the sampler shall do on individual events that occur, while using the sound the script was bundled with. An event handler in general looks like this: on event-name statements end on There are currently four events available: Event Type Description on note This event handler is executed when a new note was triggered, i.e. when hitting a key on a MIDI keyboard. on release This event handler is executed when a new note was released, i.e. when releasing a key on a MIDI keyboard. on controller This event handler is executed when a MIDI control change event occurred. For instance when turning the modulation wheel at a MIDI keyboard. on init Executed only once, as very first event handler, right after the script had been loaded. This code block is usually used to initialize variables in your script with some initial, useful data. You are free to decide for which ones of those event types you are going to write an event handler for. You can write an event handler for only one event type or write event handlers for all of those event types. Also dependent on the respective event type, there are certain things you can do and things which you can't do. But more on that later.","title":"Event Handlers"},{"location":"en/linuxsampler/docs/nksp/language/#note-events","text":"As a first example, the following tiny script will print a message to your terminal whenever you trigger a new note with your MIDI keyboard. on note message ( \"A new note was triggered!\" ) end on Probably you are also interested to see which note you triggered exactly. The sampler provides you a so called built-in variable called $EVENT_NOTE which reflects the note number (as value between 0 and 127) of the note that has just been triggered. Additionally the built-in variable $EVENT_VELOCITY provides you the velocity value (also between 0 and 127) of the note event. on note message ( \"Note \" & $EVENT_NOTE & \" was triggered with velocity \" & $EVENT_VELOCITY ) end on The & character concatenates text strings with each other. In this case it is also automatically converting the note number into a text string. The message() function is not appropriate for being used with your final production sounds, since it can lead to audio dropouts. You should only use the message() function to try out things, and to spot and debug problems with your scripts.","title":"Note Events"},{"location":"en/linuxsampler/docs/nksp/language/#release-events","text":"As counter part to the note event handler, there is also the release event handler, which is executed when a note was released. This event handler can be used similarly: on release message ( \"Note \" & $EVENT_NOTE & \" was triggered with velocity \" & $EVENT_VELOCITY ) end on Please note that you can hardly find MIDI keyboards which support release velocity. So with most keyboards this value will be 127.","title":"Release Events"},{"location":"en/linuxsampler/docs/nksp/language/#controller-events","text":"Now let's extend the first script to not only show note-on and note-off events, but also to show a message whenever you use a MIDI controller (i.e. modulation wheel, sustain pedal, etc.). on note message ( \"Note \" & $EVENT_NOTE & \" was triggered with velocity \" & $EVENT_VELOCITY ) end on on release message ( \"Note \" & $EVENT_NOTE & \" was triggered with velocity \" & $EVENT_VELOCITY ) end on on controller message ( \"MIDI Controller \" & $CC_NUM & \" changed its value to \" & $CC[$CC_NUM] ) end on It looks very similar to the note event handlers. $CC_NUM reflects the MIDI controller number of the MIDI controller that had been changed and %CC is a so called array variable, which not only contains a single number value, but instead it contains several values at the same time. The built-in %CC array variable contains the current controller values of all 127 MIDI controllers. So %CC[1] for example would give you the current controller value of the modulation wheel, and therefore %CC[$CC_NUM] reflects the new controller value of the controller that just had been changed. There is some special aspect you need to be aware about: in contrast to the MIDI standard, monophonic aftertouch (a.k.a. channel pressure) and pitch beend wheel are handled by NKSP as if they were regular MIDI controllers. So a value change of one of those two triggers a regular controller event handler to be executed. To obtain the current aftertouch value you can use %CC[$VCC_MONO_AT] , and to get the current pitch bend wheel value use %CC[$VCC_PITCH_BEND] .","title":"Controller Events"},{"location":"en/linuxsampler/docs/nksp/language/#script-load-event","text":"As the last one of the four event types available with NKSP, the following is an example of an init event handler. on init message ( \"This script has been loaded and is ready now!\" ) end on You might think, that this is probably a very exotic event. Because in fact, this \"event\" is only executed once for your script: exactly when the script was loaded by the sampler. This is not an unimportant event handler though. Because it is used to prepare your script for various purposes. We will get more about that later.","title":"Script Load Event"},{"location":"en/linuxsampler/docs/nksp/language/#comments","text":"Let's face it: software code is sometimes hard to read, especially when you are not a professional software developer who deals with such kinds of things every day. To make it more easy for you to understand, what you had in mind when you wrote a certain script three years ago, and also if some other developer might need to continue working on your scripts one day, you should place as many comments into your scripts as possible. A comment in NKSP is everything that is nested into a an opening and closing pair of curly braces. { This is a comment. } You cannot only use this to leave some human readable explanations here and there, you might also use such curly braces to quickly disable parts of your scripts for a moment, i.e. when debugging certain things. on init { The following will be prompted to the terminal when the sampler loaded this script. } message ( \"My script loaded.\" ) { This code block is commented out, so these two messages will not be displayed } { message(\"Another text\") message(\"And another one\") } end on","title":"Comments"},{"location":"en/linuxsampler/docs/nksp/language/#what-next","text":"You have completed the introduction of the NKSP real-time instrument script language at this point. You can now dive into the details of the NKSP language by moving on to the NKSP reference documentation which provides you an overview and quick access to the details of all built-in functions, built-in variables and more. \u2191 Instrument Scripts \u2192 NKSP Reference","title":"What Next?"},{"location":"en/linuxsampler/docs/nksp/reference/","text":"This document gives you an overview of all built-in functions and built-in variables provided by the NKSP real-time instrument script language. Built-In Functions These are the built-in functions available with the NKSP real-time instrument script language. Core Language Functions Most fundamental NKSP functions, independent from any purpose of being used in a sampler. Function Description abort () Stops execution of a script callback. array_equal () Check whether two arrays are equal. fork () Creates new execution instances (threads). callback_status () Returns the current status of a callback (thread). dec () Decrements the passed integer variable by one. inc () Increments the passed integer variable by one. in_range () Checks whether a value is between two other values. message () Prints text to the sampler's terminal. search () Search for a certain value within an array. sort () Sort the given array. exit () Stops execution of the current event handler instance. wait () Pauses execution for a certain amount of time. stop_wait () Resumes execution of a suspended script callback. abs () Calculates the absolute value of a given value. random () Random number generator. min () Calculates the minimum value of two given values. max () Calculates the maximum value of two given values. num_elements () Returns the size of the requested array variable. sh_left () Calculates a left bit shifted value. sh_right () Calculates a right bit shifted value. Common Sampler Functions Basic sampler related functions, independent from a particular sampler format or sampler engine. Function Description play_note () Triggers a new note. change_note () Change MIDI note number of note. change_pan () Changes panning of voices (stereo balance). change_pan_time () Changes the duration of panning (stereo balance) changes. change_pan_curve () Changes the curve type of panning (stereo balance) changes. change_play_pos () Change the sample playback position. change_tune () Changes the tuning of voices. change_tune_time () Changes the duration of tuning changes. change_tune_curve () Changes the curve type of tuning changes. change_vol () Changes the volume of voices. change_vol_time () Changes the duration of volume changes. change_vol_curve () Changes the curve type of volume changes. change_cutoff () Changes filter cutoff frequency of voices. change_reso () Changes filter resonance of voices. change_attack () Modifies the attack time of voices. change_decay () Modifies the decay time of voices. change_sustain () Modifies the sustain level of voices. change_release () Modifies the release time of voices. change_amp_lfo_depth () Modifies the amplitude LFO depth. change_amp_lfo_freq () Modifies the amplitude LFO frequency. change_pitch_lfo_depth () Modifies the pitch LFO depth. change_pitch_lfo_freq () Modifies the pitch LFO frequency. change_velo () Change MIDI velocity of note. event_status () Checks and returns whether a particular note is still alive. fade_in () Fade the requested note in. fade_out () Fade the requested note out. get_event_par () Get the current value of a specific note parameter. set_event_par () Change the value of a specific note parameter. set_controller () Creates a MIDI control change event. ignore_event () Drops the given event. ignore_controller () Drops the given MIDI control change event. note_off () Releases the requested note. set_event_mark () Adds an event to an event group. delete_event_mark () Removes an event from some event group. by_marks () Returns all events of an event group. GigaStudio Format Functions Sampler format specific functions, dedicated to the individual features of the GigaStudio format engine. Function Description gig_set_dim_zone () Changes the currently active dimension zone. same_region () Check whether two keys are mapped to the same region. Built-In Variables These are the built-in variables and built-in constants available with the NKSP realt-time instrument script language. Core Language Variables Most fundamental NKSP built-in variables, independent from any purpose of being used in a sampler. Variable Description $CALLBACK_STATUS_QUEUE Built-in constant reflecting the status of a callback to be alive but suspended. See callback_status () for details. $CALLBACK_STATUS_RUNNING Built-in constant reflecting the status of a callback to be alive and currently executing. See callback_status () for details. $CALLBACK_STATUS_TERMINATED Built-in constant reflecting the status of a callback to be not alive. See callback_status () for details. $KSP_TIMER Preserved for compatiblity reasons with KSP, returns the same value as $NKSP_REAL_TIMER (refer to the latter for details). Note that KSP's reset_ksp_timer () function is not available with NKSP. However when calculating time differences between two time stamps taken with $NKSP_REAL_TIMER , calling such a reset function is not required, because the underlying clock does not stop when it reached its value limit (which happens every 71 minutes), instead the clock will automatically restart from zero and the calculated time difference even between such transitions will reflect correct durations. $NKSP_PERF_TIMER Returns the current performance time stamp (in microseconds) of the script running. You may read this variable from time to time to take time stamps which can be used to calculate the time difference (in microseconds) which elapsed between them. A performance time stamp is based on the script's actual CPU execution time. So the internal clock which is used for generating such time stamps is only running forward if the respective script is actually executed by the CPU. Whenever your script is not really executed by the CPU (i.e. because your script got suspended by a wait () call or got forcely suspended due to real-time constraints, or when the entire sampler application got suspended by the OS for other applications or OS tasks) then the underlying internal clock is paused as well. You should only use this built-in variable for script development purposes (i.e. for bench marking the performance of your script). You should not use it with your final production sounds! It is not appropriate for being used in a musical context, because when an offline bounce is performed for instance, the musical timing will be completely unrelated to the CPU execution time. Plus using this variable may cause audio drop outs on some systems. In a musical context you should use $ENGINE_UPTIME instead, which is also safe for offline bounces. On some systems $NKSP_REAL_TIMER and $NKSP_PERF_TIMER will actually return the same value. So the difference between them is not implemented for all systems at the moment. %NKSP_CALLBACK_CHILD_ID[] Reflects the callback IDs of all child threads which the current script callback instance spawned by having called fork () before. See the latter function for details about this array variable. $NKSP_CALLBACK_PARENT_ID If the current execution thread is a child thread spawned by a fork () call before, then this variable reflects the callback ID of the parent thread which created this child thread. Otherwise this variable is 0. See fork () for more details about this variable. $NKSP_REAL_TIMER Returns the current time stamp in reality (in microseconds). You may read this variable from time to time to take time stamps which can be used to calculate the time difference (in microseconds) which elapsed between them. A \"real\" time stamp is based on an internal clock which constantly proceeds, so this internal clock also continues counting while your script is either suspended (i.e. because your script got suspended by a wait () call or got forcely suspended due to real-time constraints) and it also continues counting even if the entire sampler application got suspended by the OS (i.e. to execute other applications for multi-tasking or to perform OS tasks). You should only use this built-in variable for script development purposes (i.e. for bench marking the performance of your script). You should not use it with your final production sounds! It is not appropriate for being used in a musical context, because when an offline bounce is performed for instance, the musical timing will be completely unrelated to the CPU execution time. Plus using this variable may cause audio drop outs on some systems. In a musical context you should use $ENGINE_UPTIME instead, which is also safe for offline bounces. On some systems $NKSP_REAL_TIMER and $NKSP_PERF_TIMER will actually return the same value. So the difference between them is not implemented for all systems at the moment. $NI_CALLBACK_ID Reflects the current event handler instance's unique callback ID. For the same event type there may be more than one event handler instances running. Each one of them has its own callback ID. You can get the current event handler instance's callback ID by reading this built-in variable. $NI_CALLBACK_TYPE Reflects the event type of the current event handler. This variable may reflect one of the following built-in constants: $NI_CB_TYPE_INIT , $NI_CB_TYPE_NOTE , $NI_CB_TYPE_RELEASE , $NI_CB_TYPE_CONTROLLER . $NI_CB_TYPE_INIT Built-in constant reflecting an init event handler type. $NI_CB_TYPE_NOTE Built-in constant reflecting a note event handler type. $NI_CB_TYPE_RELEASE Built-in constant reflecting a release event handler type. $NI_CB_TYPE_CONTROLLER Built-in constant reflecting a controller event handler type. $NKSP_IGNORE_WAIT If this boolean built-in variable is 1 then all calls of your event handler instance to function wait () will be ignored. This may for example be the case if another event handler instance resumed your paused script by calling stop_wait () and passing 1 to the 2nd argument of that function. Common Sampler Variables Basic sampler related built-in variables and constants, independent from a particular sampler format or sampler engine. Variable Description %ALL_EVENTS Note IDs of all currently active notes of the current sampler part (a.k.a. sampler channel). This may be passed to many built-in functions like note_off (). This array variable only contains IDs of notes which were launched due to MIDI note-on events. This variable does not contain IDs of child notes (i.e. notes which were launched programmatically by calling play_note ()). In contrast to KSP this variable is an integer array type, whereas KSP's pendent of this built-in variable is an integer constant (scalar) called $ALL_EVENTS . Using the latter with NKSP will cause a parser warning, the behavior will be the same though. $CC_NUM MIDI controller number that caused the controller handler to be executed (only useful in the context of a controller handler). %CC[] Provides access to all current MIDI controller values. This can be used in any context. Use the respective MIDI controller number as index to this integer array variable. For instance %CC[1] would give you the current value of the modulation wheel. $EVENT_ID ID of the event that caused the current event handler to be executed. In the context of a note handler this would be the event ID of the note, within a controller handler it would be the controller event ID, etc. $EVENT_NOTE MIDI note number that caused a note related handler to be executed (only useful in the context of a note or release handler). $EVENT_VELOCITY MIDI velocity value of the note that caused that note related handler to be executed (only useful in the context of a note or release handler). $EVENT_STATUS_INACTIVE Constant bit flag used as possible return value by event_status () in case the requested note is not \"alive\". $EVENT_STATUS_NOTE_QUEUE Constant bit flag used as possible return value by event_status () in case the requested note is still \"alive\". $EVENT_PAR_NOTE Constant value symbolizing the \"note number\" parameter. See get_event_par () and set_event_par () for details. $EVENT_PAR_TUNE Constant value symbolizing the \"tune\" parameter. See get_event_par () and set_event_par () for details. $EVENT_PAR_VELOCITY Constant value symbolizing the \"note velocity\" parameter. See get_event_par () and set_event_par () for details. $EVENT_PAR_VOLUME Constant value symbolizing the \"volume\" parameter. See get_event_par () and set_event_par () for details. $EVENT_PAR_0 to $EVENT_PAR_3 Four constant values symbolizing the 4 possible user specific parameters, which i.e. might be used to pass data from one script (slot) to another script (slot). See get_event_par () and set_event_par () for details. %KEY_DOWN[] This can be used in any context to check whether a certain MIDI key is currently pressed down. Use the respective MIDI note number as index to this array variable (see also event_status ()). $NKSP_EASE_IN_EASE_OUT Used to select a fade curve with \"ease in and ease out\" shape. $NKSP_LINEAR Used to select a fade curve with linear shape. $VCC_MONO_AT Constant identifying the MIDI monophonic aftertouch controller (also called MIDI channel pressure ). This is somewhat different than in the MIDI standard. With NKSP aftertouch is handled like an additional \"regular\" MIDI CC controller. Therefore use %CC[$VCC_MONO_AT] to obtain the current aftertouch value in the context of a controller event handler. $VCC_PITCH_BEND Constant identifying the pitch bend wheel controller. This is somewhat different than in the MIDI standard. With NKSP pitch bend is handled like an additional \"regular\" MIDI CC controller. Therefore use %CC[$VCC_PITCH_BEND] to obtain the current pitch bend wheel value in the context of a controller event handler. $MARK_1 to $MARK_28 Used to select one of the available 28 event groups. See set_event_mark () for details. $ENGINE_UPTIME Returns the current time stamp (in milliseconds) for being used in a musical context. You may read this variable from time to time to take time stamps which can be used to calculate the time difference (in milliseconds) which elapsed between them. These timing values are based on the internal sample rate and thus it can safely be used to perform musical timing related tasks in your scripts. Especially your script will also continue to behave correctly when an offline bounce of a song is performed. GigaStudio Format Variables Sampler format specific built-in variables and constants, dedicated to the individual features of the GigaStudio format engine. Variable Description $GIG_DIM_CHANNEL Constant that identifies the stereo dimension . $GIG_DIM_LAYER Constant that identifies the layer dimension . $GIG_DIM_VELOCITY Constant that identifies the velocity dimension . $GIG_DIM_AFTERTOUCH Constant that identifies the aftertouch dimension . $GIG_DIM_RELEASE Constant that identifies the release trigger dimension . $GIG_DIM_KEYBOARD Constant that identifies the keyboard position dimension . $GIG_DIM_ROUNDROBIN Constant that identifies the round robin dimension . $GIG_DIM_RANDOM Constant that identifies the random dimension . $GIG_DIM_SMARTMIDI Constant that identifies the start MIDI dimension (a.k.a iMIDI rules) . $GIG_DIM_ROUNDROBINKEY Constant that identifies the round robin key dimension . $GIG_DIM_MODWHEEL Constant that identifies the modulation wheel dimension . $GIG_DIM_SUSTAIN Constant that identifies the sustain pedal dimension (a.k.a. hold pedal) . $GIG_DIM_PORTAMENTO Constant that identifies the portamento MIDI controller dimension . $GIG_DIM_SOSTENUTO Constant that identifies the sostenuto MIDI controller dimension . $GIG_DIM_SOFT Constant that identifies the soft pedal dimension . $GIG_DIM_BREATH Constant that identifies the breath controller dimension . $GIG_DIM_FOOT Constant that identifies the foot pedal dimension . $GIG_DIM_PORTAMENTOTIME Constant that identifies the portamento time controller dimension . $GIG_DIM_EFFECT1 Constant that identifies the effect 1 MIDI controller dimension . $GIG_DIM_EFFECT2 Constant that identifies the effect 2 MIDI controller dimension . $GIG_DIM_EFFECT1DEPTH Constant that identifies the effect 1 depth MIDI controller dimension . $GIG_DIM_EFFECT2DEPTH Constant that identifies the effect 2 depth MIDI controller dimension . $GIG_DIM_EFFECT3DEPTH Constant that identifies the effect 3 depth MIDI controller dimension . $GIG_DIM_EFFECT4DEPTH Constant that identifies the effect 4 depth MIDI controller dimension . $GIG_DIM_EFFECT5DEPTH Constant that identifies the effect 5 depth MIDI controller dimension . $GIG_DIM_GENPURPOSE1 Constant that identifies the general purpose 1 MIDI controller dimension . $GIG_DIM_GENPURPOSE2 Constant that identifies the general purpose 2 MIDI controller dimension . $GIG_DIM_GENPURPOSE3 Constant that identifies the general purpose 3 MIDI controller dimension . $GIG_DIM_GENPURPOSE4 Constant that identifies the general purpose 4 MIDI controller dimension . $GIG_DIM_GENPURPOSE5 Constant that identifies the general purpose 5 MIDI controller dimension . $GIG_DIM_GENPURPOSE6 Constant that identifies the general purpose 6 MIDI controller dimension . $GIG_DIM_GENPURPOSE7 Constant that identifies the general purpose 7 MIDI controller dimension . $GIG_DIM_GENPURPOSE8 Constant that identifies the general purpose 8 MIDI controller dimension . Built-In Preprocessor Conditions These are the built-in preprocessor conditions available with the NKSP realt-time instrument script language. Core Language Preprocessor Conditions Most fundamental NKSP built-in preprocessor conditions, independent from any purpose of being used in a sampler. Condition Description NKSP_NO_MESSAGE By default this condition is not set. By explicitly enabling this condition with SET_CONDITION(NKSP_NO_MESSAGE) it causes all subsequent message () calls to be ignored and filtered out on preprocessor level. See function message () for details. \u2191 NKSP Language \u2192 abort() function","title":"NKSP Reference"},{"location":"en/linuxsampler/docs/nksp/reference/#built-in-functions","text":"These are the built-in functions available with the NKSP real-time instrument script language.","title":"Built-In Functions"},{"location":"en/linuxsampler/docs/nksp/reference/#core-language-functions","text":"Most fundamental NKSP functions, independent from any purpose of being used in a sampler. Function Description abort () Stops execution of a script callback. array_equal () Check whether two arrays are equal. fork () Creates new execution instances (threads). callback_status () Returns the current status of a callback (thread). dec () Decrements the passed integer variable by one. inc () Increments the passed integer variable by one. in_range () Checks whether a value is between two other values. message () Prints text to the sampler's terminal. search () Search for a certain value within an array. sort () Sort the given array. exit () Stops execution of the current event handler instance. wait () Pauses execution for a certain amount of time. stop_wait () Resumes execution of a suspended script callback. abs () Calculates the absolute value of a given value. random () Random number generator. min () Calculates the minimum value of two given values. max () Calculates the maximum value of two given values. num_elements () Returns the size of the requested array variable. sh_left () Calculates a left bit shifted value. sh_right () Calculates a right bit shifted value.","title":"Core Language Functions"},{"location":"en/linuxsampler/docs/nksp/reference/#common-sampler-functions","text":"Basic sampler related functions, independent from a particular sampler format or sampler engine. Function Description play_note () Triggers a new note. change_note () Change MIDI note number of note. change_pan () Changes panning of voices (stereo balance). change_pan_time () Changes the duration of panning (stereo balance) changes. change_pan_curve () Changes the curve type of panning (stereo balance) changes. change_play_pos () Change the sample playback position. change_tune () Changes the tuning of voices. change_tune_time () Changes the duration of tuning changes. change_tune_curve () Changes the curve type of tuning changes. change_vol () Changes the volume of voices. change_vol_time () Changes the duration of volume changes. change_vol_curve () Changes the curve type of volume changes. change_cutoff () Changes filter cutoff frequency of voices. change_reso () Changes filter resonance of voices. change_attack () Modifies the attack time of voices. change_decay () Modifies the decay time of voices. change_sustain () Modifies the sustain level of voices. change_release () Modifies the release time of voices. change_amp_lfo_depth () Modifies the amplitude LFO depth. change_amp_lfo_freq () Modifies the amplitude LFO frequency. change_pitch_lfo_depth () Modifies the pitch LFO depth. change_pitch_lfo_freq () Modifies the pitch LFO frequency. change_velo () Change MIDI velocity of note. event_status () Checks and returns whether a particular note is still alive. fade_in () Fade the requested note in. fade_out () Fade the requested note out. get_event_par () Get the current value of a specific note parameter. set_event_par () Change the value of a specific note parameter. set_controller () Creates a MIDI control change event. ignore_event () Drops the given event. ignore_controller () Drops the given MIDI control change event. note_off () Releases the requested note. set_event_mark () Adds an event to an event group. delete_event_mark () Removes an event from some event group. by_marks () Returns all events of an event group.","title":"Common Sampler Functions"},{"location":"en/linuxsampler/docs/nksp/reference/#gigastudio-format-functions","text":"Sampler format specific functions, dedicated to the individual features of the GigaStudio format engine. Function Description gig_set_dim_zone () Changes the currently active dimension zone. same_region () Check whether two keys are mapped to the same region.","title":"GigaStudio Format Functions"},{"location":"en/linuxsampler/docs/nksp/reference/#built-in-variables","text":"These are the built-in variables and built-in constants available with the NKSP realt-time instrument script language.","title":"Built-In Variables"},{"location":"en/linuxsampler/docs/nksp/reference/#core-language-variables","text":"Most fundamental NKSP built-in variables, independent from any purpose of being used in a sampler. Variable Description $CALLBACK_STATUS_QUEUE Built-in constant reflecting the status of a callback to be alive but suspended. See callback_status () for details. $CALLBACK_STATUS_RUNNING Built-in constant reflecting the status of a callback to be alive and currently executing. See callback_status () for details. $CALLBACK_STATUS_TERMINATED Built-in constant reflecting the status of a callback to be not alive. See callback_status () for details. $KSP_TIMER Preserved for compatiblity reasons with KSP, returns the same value as $NKSP_REAL_TIMER (refer to the latter for details). Note that KSP's reset_ksp_timer () function is not available with NKSP. However when calculating time differences between two time stamps taken with $NKSP_REAL_TIMER , calling such a reset function is not required, because the underlying clock does not stop when it reached its value limit (which happens every 71 minutes), instead the clock will automatically restart from zero and the calculated time difference even between such transitions will reflect correct durations. $NKSP_PERF_TIMER Returns the current performance time stamp (in microseconds) of the script running. You may read this variable from time to time to take time stamps which can be used to calculate the time difference (in microseconds) which elapsed between them. A performance time stamp is based on the script's actual CPU execution time. So the internal clock which is used for generating such time stamps is only running forward if the respective script is actually executed by the CPU. Whenever your script is not really executed by the CPU (i.e. because your script got suspended by a wait () call or got forcely suspended due to real-time constraints, or when the entire sampler application got suspended by the OS for other applications or OS tasks) then the underlying internal clock is paused as well. You should only use this built-in variable for script development purposes (i.e. for bench marking the performance of your script). You should not use it with your final production sounds! It is not appropriate for being used in a musical context, because when an offline bounce is performed for instance, the musical timing will be completely unrelated to the CPU execution time. Plus using this variable may cause audio drop outs on some systems. In a musical context you should use $ENGINE_UPTIME instead, which is also safe for offline bounces. On some systems $NKSP_REAL_TIMER and $NKSP_PERF_TIMER will actually return the same value. So the difference between them is not implemented for all systems at the moment. %NKSP_CALLBACK_CHILD_ID[] Reflects the callback IDs of all child threads which the current script callback instance spawned by having called fork () before. See the latter function for details about this array variable. $NKSP_CALLBACK_PARENT_ID If the current execution thread is a child thread spawned by a fork () call before, then this variable reflects the callback ID of the parent thread which created this child thread. Otherwise this variable is 0. See fork () for more details about this variable. $NKSP_REAL_TIMER Returns the current time stamp in reality (in microseconds). You may read this variable from time to time to take time stamps which can be used to calculate the time difference (in microseconds) which elapsed between them. A \"real\" time stamp is based on an internal clock which constantly proceeds, so this internal clock also continues counting while your script is either suspended (i.e. because your script got suspended by a wait () call or got forcely suspended due to real-time constraints) and it also continues counting even if the entire sampler application got suspended by the OS (i.e. to execute other applications for multi-tasking or to perform OS tasks). You should only use this built-in variable for script development purposes (i.e. for bench marking the performance of your script). You should not use it with your final production sounds! It is not appropriate for being used in a musical context, because when an offline bounce is performed for instance, the musical timing will be completely unrelated to the CPU execution time. Plus using this variable may cause audio drop outs on some systems. In a musical context you should use $ENGINE_UPTIME instead, which is also safe for offline bounces. On some systems $NKSP_REAL_TIMER and $NKSP_PERF_TIMER will actually return the same value. So the difference between them is not implemented for all systems at the moment. $NI_CALLBACK_ID Reflects the current event handler instance's unique callback ID. For the same event type there may be more than one event handler instances running. Each one of them has its own callback ID. You can get the current event handler instance's callback ID by reading this built-in variable. $NI_CALLBACK_TYPE Reflects the event type of the current event handler. This variable may reflect one of the following built-in constants: $NI_CB_TYPE_INIT , $NI_CB_TYPE_NOTE , $NI_CB_TYPE_RELEASE , $NI_CB_TYPE_CONTROLLER . $NI_CB_TYPE_INIT Built-in constant reflecting an init event handler type. $NI_CB_TYPE_NOTE Built-in constant reflecting a note event handler type. $NI_CB_TYPE_RELEASE Built-in constant reflecting a release event handler type. $NI_CB_TYPE_CONTROLLER Built-in constant reflecting a controller event handler type. $NKSP_IGNORE_WAIT If this boolean built-in variable is 1 then all calls of your event handler instance to function wait () will be ignored. This may for example be the case if another event handler instance resumed your paused script by calling stop_wait () and passing 1 to the 2nd argument of that function.","title":"Core Language Variables"},{"location":"en/linuxsampler/docs/nksp/reference/#common-sampler-variables","text":"Basic sampler related built-in variables and constants, independent from a particular sampler format or sampler engine. Variable Description %ALL_EVENTS Note IDs of all currently active notes of the current sampler part (a.k.a. sampler channel). This may be passed to many built-in functions like note_off (). This array variable only contains IDs of notes which were launched due to MIDI note-on events. This variable does not contain IDs of child notes (i.e. notes which were launched programmatically by calling play_note ()). In contrast to KSP this variable is an integer array type, whereas KSP's pendent of this built-in variable is an integer constant (scalar) called $ALL_EVENTS . Using the latter with NKSP will cause a parser warning, the behavior will be the same though. $CC_NUM MIDI controller number that caused the controller handler to be executed (only useful in the context of a controller handler). %CC[] Provides access to all current MIDI controller values. This can be used in any context. Use the respective MIDI controller number as index to this integer array variable. For instance %CC[1] would give you the current value of the modulation wheel. $EVENT_ID ID of the event that caused the current event handler to be executed. In the context of a note handler this would be the event ID of the note, within a controller handler it would be the controller event ID, etc. $EVENT_NOTE MIDI note number that caused a note related handler to be executed (only useful in the context of a note or release handler). $EVENT_VELOCITY MIDI velocity value of the note that caused that note related handler to be executed (only useful in the context of a note or release handler). $EVENT_STATUS_INACTIVE Constant bit flag used as possible return value by event_status () in case the requested note is not \"alive\". $EVENT_STATUS_NOTE_QUEUE Constant bit flag used as possible return value by event_status () in case the requested note is still \"alive\". $EVENT_PAR_NOTE Constant value symbolizing the \"note number\" parameter. See get_event_par () and set_event_par () for details. $EVENT_PAR_TUNE Constant value symbolizing the \"tune\" parameter. See get_event_par () and set_event_par () for details. $EVENT_PAR_VELOCITY Constant value symbolizing the \"note velocity\" parameter. See get_event_par () and set_event_par () for details. $EVENT_PAR_VOLUME Constant value symbolizing the \"volume\" parameter. See get_event_par () and set_event_par () for details. $EVENT_PAR_0 to $EVENT_PAR_3 Four constant values symbolizing the 4 possible user specific parameters, which i.e. might be used to pass data from one script (slot) to another script (slot). See get_event_par () and set_event_par () for details. %KEY_DOWN[] This can be used in any context to check whether a certain MIDI key is currently pressed down. Use the respective MIDI note number as index to this array variable (see also event_status ()). $NKSP_EASE_IN_EASE_OUT Used to select a fade curve with \"ease in and ease out\" shape. $NKSP_LINEAR Used to select a fade curve with linear shape. $VCC_MONO_AT Constant identifying the MIDI monophonic aftertouch controller (also called MIDI channel pressure ). This is somewhat different than in the MIDI standard. With NKSP aftertouch is handled like an additional \"regular\" MIDI CC controller. Therefore use %CC[$VCC_MONO_AT] to obtain the current aftertouch value in the context of a controller event handler. $VCC_PITCH_BEND Constant identifying the pitch bend wheel controller. This is somewhat different than in the MIDI standard. With NKSP pitch bend is handled like an additional \"regular\" MIDI CC controller. Therefore use %CC[$VCC_PITCH_BEND] to obtain the current pitch bend wheel value in the context of a controller event handler. $MARK_1 to $MARK_28 Used to select one of the available 28 event groups. See set_event_mark () for details. $ENGINE_UPTIME Returns the current time stamp (in milliseconds) for being used in a musical context. You may read this variable from time to time to take time stamps which can be used to calculate the time difference (in milliseconds) which elapsed between them. These timing values are based on the internal sample rate and thus it can safely be used to perform musical timing related tasks in your scripts. Especially your script will also continue to behave correctly when an offline bounce of a song is performed.","title":"Common Sampler Variables"},{"location":"en/linuxsampler/docs/nksp/reference/#gigastudio-format-variables","text":"Sampler format specific built-in variables and constants, dedicated to the individual features of the GigaStudio format engine. Variable Description $GIG_DIM_CHANNEL Constant that identifies the stereo dimension . $GIG_DIM_LAYER Constant that identifies the layer dimension . $GIG_DIM_VELOCITY Constant that identifies the velocity dimension . $GIG_DIM_AFTERTOUCH Constant that identifies the aftertouch dimension . $GIG_DIM_RELEASE Constant that identifies the release trigger dimension . $GIG_DIM_KEYBOARD Constant that identifies the keyboard position dimension . $GIG_DIM_ROUNDROBIN Constant that identifies the round robin dimension . $GIG_DIM_RANDOM Constant that identifies the random dimension . $GIG_DIM_SMARTMIDI Constant that identifies the start MIDI dimension (a.k.a iMIDI rules) . $GIG_DIM_ROUNDROBINKEY Constant that identifies the round robin key dimension . $GIG_DIM_MODWHEEL Constant that identifies the modulation wheel dimension . $GIG_DIM_SUSTAIN Constant that identifies the sustain pedal dimension (a.k.a. hold pedal) . $GIG_DIM_PORTAMENTO Constant that identifies the portamento MIDI controller dimension . $GIG_DIM_SOSTENUTO Constant that identifies the sostenuto MIDI controller dimension . $GIG_DIM_SOFT Constant that identifies the soft pedal dimension . $GIG_DIM_BREATH Constant that identifies the breath controller dimension . $GIG_DIM_FOOT Constant that identifies the foot pedal dimension . $GIG_DIM_PORTAMENTOTIME Constant that identifies the portamento time controller dimension . $GIG_DIM_EFFECT1 Constant that identifies the effect 1 MIDI controller dimension . $GIG_DIM_EFFECT2 Constant that identifies the effect 2 MIDI controller dimension . $GIG_DIM_EFFECT1DEPTH Constant that identifies the effect 1 depth MIDI controller dimension . $GIG_DIM_EFFECT2DEPTH Constant that identifies the effect 2 depth MIDI controller dimension . $GIG_DIM_EFFECT3DEPTH Constant that identifies the effect 3 depth MIDI controller dimension . $GIG_DIM_EFFECT4DEPTH Constant that identifies the effect 4 depth MIDI controller dimension . $GIG_DIM_EFFECT5DEPTH Constant that identifies the effect 5 depth MIDI controller dimension . $GIG_DIM_GENPURPOSE1 Constant that identifies the general purpose 1 MIDI controller dimension . $GIG_DIM_GENPURPOSE2 Constant that identifies the general purpose 2 MIDI controller dimension . $GIG_DIM_GENPURPOSE3 Constant that identifies the general purpose 3 MIDI controller dimension . $GIG_DIM_GENPURPOSE4 Constant that identifies the general purpose 4 MIDI controller dimension . $GIG_DIM_GENPURPOSE5 Constant that identifies the general purpose 5 MIDI controller dimension . $GIG_DIM_GENPURPOSE6 Constant that identifies the general purpose 6 MIDI controller dimension . $GIG_DIM_GENPURPOSE7 Constant that identifies the general purpose 7 MIDI controller dimension . $GIG_DIM_GENPURPOSE8 Constant that identifies the general purpose 8 MIDI controller dimension .","title":"GigaStudio Format Variables"},{"location":"en/linuxsampler/docs/nksp/reference/#built-in-preprocessor-conditions","text":"These are the built-in preprocessor conditions available with the NKSP realt-time instrument script language.","title":"Built-In Preprocessor Conditions"},{"location":"en/linuxsampler/docs/nksp/reference/#core-language-preprocessor-conditions","text":"Most fundamental NKSP built-in preprocessor conditions, independent from any purpose of being used in a sampler. Condition Description NKSP_NO_MESSAGE By default this condition is not set. By explicitly enabling this condition with SET_CONDITION(NKSP_NO_MESSAGE) it causes all subsequent message () calls to be ignored and filtered out on preprocessor level. See function message () for details. \u2191 NKSP Language \u2192 abort() function","title":"Core Language Preprocessor Conditions"},{"location":"en/linuxsampler/docs/sfz/","text":"The SFZ file format is a human readable instrument definition file format for audio sample based virtual instruments. In contrast to many other sampler file formats you can open and modify such .sfz files simply with any text editor. This SFZ documentation is yet under construction. In the meantime you may want to have a look at the old and currently still separate list of opcodes supported by LinuxSampler . You want to help filling up the missing information about the SFZ file format on this site? Great! Check out the source files of this SFZ documentation on our Subversion server and get in touch with us ! Sections A sfz file is divided into sections. A section defines in which context the subsequent statements in the sfz file shall be interpreted as. For example You may want to declare a lowpass filter to be used either for the entire sfz instrument, or you may declare the lowpass filter to be only used for a certain region on the keyboard instead. A section is introduced by its section name, where the section name is placed in a pair of angle brackets. The section name is then followed by the respective sfz opcodes which shall be assigned to that particular section. The sections available with sfz are: Section Standard Description < global > SFZ v1 Declarations which shall apply to the entire instrument. < group > SFZ v1 TODO ... < region > SFZ v1 TODO ... < control > ? TODO ... < curve > ? TODO ... < effect > ? TODO ... Opcodes The actual individual statements which make up the articulation definition of a sfz instrument are called opcodes. For example there is an opcode for loading and assigning a sample file to be played. And there is an opcode for defining envelope parameters, and so on. The opcodes available with the SFZ file format are: Section Standard Description hibend SFZ v1 Assign pitch pend upper limit to region. hichan SFZ v1 Assign MIDI channel upper limit to region. hikey SFZ v1 Assign MIDI note number upper limit to region. hirand SFZ v1 Assign random number generator upper limit to region. hivel SFZ v1 Assign MIDI velocity upper limit to region. key SFZ v1 Assign precise note number to region. lobend SFZ v1 Assign pitch bend lower limit to region. lochan SFZ v1 Assign MIDI channel lower limit to region. lokey SFZ v1 Assign MIDI note number lower limit to region. lorand SFZ v1 Assign random number generator lower limit to region. lovel SFZ v1 Assign MIDI velocity lower limit to region. sample SFZ v1 Load and assign an audio sample file. script LinuxSampler Ext. Load an real-time instrument script for the instrument. seq_length SFZ v1 Defines a round robin length. seq_position SFZ v1 Assigns a round robin position to a region. set_ccN SFZ v2 Assign initial value to MIDI controller. transpose SFZ v1 Transpose by given amount of semi tones. tune SFZ v1 Fine tuning by given amount of cents. TODO... \u2191 LinuxSampler Documents","title":"SFZ File Format"},{"location":"en/linuxsampler/docs/sfz/#sections","text":"A sfz file is divided into sections. A section defines in which context the subsequent statements in the sfz file shall be interpreted as. For example You may want to declare a lowpass filter to be used either for the entire sfz instrument, or you may declare the lowpass filter to be only used for a certain region on the keyboard instead. A section is introduced by its section name, where the section name is placed in a pair of angle brackets. The section name is then followed by the respective sfz opcodes which shall be assigned to that particular section. The sections available with sfz are: Section Standard Description < global > SFZ v1 Declarations which shall apply to the entire instrument. < group > SFZ v1 TODO ... < region > SFZ v1 TODO ... < control > ? TODO ... < curve > ? TODO ... < effect > ? TODO ...","title":"Sections"},{"location":"en/linuxsampler/docs/sfz/#opcodes","text":"The actual individual statements which make up the articulation definition of a sfz instrument are called opcodes. For example there is an opcode for loading and assigning a sample file to be played. And there is an opcode for defining envelope parameters, and so on. The opcodes available with the SFZ file format are: Section Standard Description hibend SFZ v1 Assign pitch pend upper limit to region. hichan SFZ v1 Assign MIDI channel upper limit to region. hikey SFZ v1 Assign MIDI note number upper limit to region. hirand SFZ v1 Assign random number generator upper limit to region. hivel SFZ v1 Assign MIDI velocity upper limit to region. key SFZ v1 Assign precise note number to region. lobend SFZ v1 Assign pitch bend lower limit to region. lochan SFZ v1 Assign MIDI channel lower limit to region. lokey SFZ v1 Assign MIDI note number lower limit to region. lorand SFZ v1 Assign random number generator lower limit to region. lovel SFZ v1 Assign MIDI velocity lower limit to region. sample SFZ v1 Load and assign an audio sample file. script LinuxSampler Ext. Load an real-time instrument script for the instrument. seq_length SFZ v1 Defines a round robin length. seq_position SFZ v1 Assigns a round robin position to a region. set_ccN SFZ v2 Assign initial value to MIDI controller. transpose SFZ v1 Transpose by given amount of semi tones. tune SFZ v1 Fine tuning by given amount of cents. TODO... \u2191 LinuxSampler Documents","title":"Opcodes"},{"location":"en/linuxsampler/docs/sfz/opcode/hibend/","text":"Causes the associated region to play when a constraint on MIDI pitch bend is respected. Used in conjunction with lobend , it makes the region play when the last pitch bend value received is equal to or higher than lobend and equal to or lower than hibend . Opcode Prototype hibend = [upper limit] Parameter The mandatory [upper limit] parameter defines the range's upper limit. This parameter only accepts valid MIDI pitch bend values (from -8192 to 8192). Allowed Sections May be used in sections < global > and < region >. Examples Defines a guitar instrument with two regions assigned to different position of the pitch bend wheel. < region > sample =mysamples/guitar-1.wav lobend =-5000 hibend =0 < region > sample =mysamples/guitar-2.wav lobend =1 hibend =5000 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2191 SFZ File Format \u2192 hichan Opcode","title":"hibend Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/hibend/#opcode-prototype","text":"hibend = [upper limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/hibend/#parameter","text":"The mandatory [upper limit] parameter defines the range's upper limit. This parameter only accepts valid MIDI pitch bend values (from -8192 to 8192).","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/hibend/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/hibend/#examples","text":"Defines a guitar instrument with two regions assigned to different position of the pitch bend wheel. < region > sample =mysamples/guitar-1.wav lobend =-5000 hibend =0 < region > sample =mysamples/guitar-2.wav lobend =1 hibend =5000","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/hibend/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2191 SFZ File Format \u2192 hichan Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/hichan/","text":"Causes the associated region to play when a constraint on MIDI channel is respected. Used in conjunction with lochan , it makes the region play when the incoming note's MIDI channel is equal to or higher than lochan and equal to or lower than hichan . Opcode Prototype hichan = [upper limit] Parameter The mandatory [upper limit] parameter defines the range's upper limit. This parameter only accepts valid MIDI channel numbers (from 1 to 16). Allowed Sections May be used in sections < global > and < region >. Examples A region triggered only by notes on MIDI channel 1. < region > sample =mysamples/piano_C1.wav lochan =1 hichan =1 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hibend Opcode \u2191 SFZ File Format \u2192 hikey Opcode","title":"hichan Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/hichan/#opcode-prototype","text":"hichan = [upper limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/hichan/#parameter","text":"The mandatory [upper limit] parameter defines the range's upper limit. This parameter only accepts valid MIDI channel numbers (from 1 to 16).","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/hichan/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/hichan/#examples","text":"A region triggered only by notes on MIDI channel 1. < region > sample =mysamples/piano_C1.wav lochan =1 hichan =1","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/hichan/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hibend Opcode \u2191 SFZ File Format \u2192 hikey Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/hikey/","text":"Causes the associated region to play when a constraint on MIDI note is respected. Used in conjunction with lokey , it makes the region play when the incoming note is equal to or higher than lokey and equal to or lower than hikey . Opcode Prototype hikey = [upper limit] Parameter The mandatory [upper limit] parameter defines the range's upper limit. This parameter only accepts valid MIDI note numbers (from 0 to 127) or names (from C-1 to G9): Note Numbers Note Names Octave 0 to 11 C-1 to B-1 -1 12 to 23 C0 to B0 0 24 to 35 C1 to B1 1 36 to 47 C2 to B2 2 48 to 59 C3 to B3 3 60 to 71 C4 to B4 4 72 to 83 C5 to B5 5 84 to 95 C6 to B6 6 96 to 107 C7 to B7 7 108 to 119 C8 to B8 8 120 to 127 C9 to G9 9 Allowed Sections May be used in sections < global > and < region >. Examples Defines one region for each of three octaves. < region > sample =mysamples/octave01.wav lokey =24 hikey =35 < region > sample =mysamples/octave02.wav lokey =C2 hikey =B2 < region > sample =mysamples/octave03.wav lokey =48 hikey =59 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hichan Opcode \u2191 SFZ File Format \u2192 hirand Opcode","title":"hikey Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/hikey/#opcode-prototype","text":"hikey = [upper limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/hikey/#parameter","text":"The mandatory [upper limit] parameter defines the range's upper limit. This parameter only accepts valid MIDI note numbers (from 0 to 127) or names (from C-1 to G9): Note Numbers Note Names Octave 0 to 11 C-1 to B-1 -1 12 to 23 C0 to B0 0 24 to 35 C1 to B1 1 36 to 47 C2 to B2 2 48 to 59 C3 to B3 3 60 to 71 C4 to B4 4 72 to 83 C5 to B5 5 84 to 95 C6 to B6 6 96 to 107 C7 to B7 7 108 to 119 C8 to B8 8 120 to 127 C9 to G9 9","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/hikey/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/hikey/#examples","text":"Defines one region for each of three octaves. < region > sample =mysamples/octave01.wav lokey =24 hikey =35 < region > sample =mysamples/octave02.wav lokey =C2 hikey =B2 < region > sample =mysamples/octave03.wav lokey =48 hikey =59","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/hikey/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hichan Opcode \u2191 SFZ File Format \u2192 hirand Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/hirand/","text":"Causes the associated region to play when generated random number is between a defined range. Used in conjunction with lorand , it makes the region play when the value of a random number generated by a note-on event is equal to or higher than lorand and lower than hirand . Opcode Prototype hirand = [upper limit] Parameter The mandatory [upper limit] parameter defines the range's upper limit. The accepted values for this parameter are in the 0-1 range. Allowed Sections May be used in section < region >. Examples Sets a pool of four clap samples, one of them is randomly choosen at every note-on event. < region > sample =mysamples/clap_01.wav lorand =0 hirand =0.250 < region > sample =mysamples/clap_02.wav lorand =0.250 hirand =0.500 < region > sample =mysamples/clap_03.wav lorand =0.500 hirand =0.750 < region > sample =mysamples/clap_04.wav lorand =0.750 hirand =1 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hikey Opcode \u2191 SFZ File Format \u2192 hivel Opcode","title":"hirand Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/hirand/#opcode-prototype","text":"hirand = [upper limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/hirand/#parameter","text":"The mandatory [upper limit] parameter defines the range's upper limit. The accepted values for this parameter are in the 0-1 range.","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/hirand/#allowed-sections","text":"May be used in section < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/hirand/#examples","text":"Sets a pool of four clap samples, one of them is randomly choosen at every note-on event. < region > sample =mysamples/clap_01.wav lorand =0 hirand =0.250 < region > sample =mysamples/clap_02.wav lorand =0.250 hirand =0.500 < region > sample =mysamples/clap_03.wav lorand =0.500 hirand =0.750 < region > sample =mysamples/clap_04.wav lorand =0.750 hirand =1","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/hirand/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hikey Opcode \u2191 SFZ File Format \u2192 hivel Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/hivel/","text":"Causes the associated region to play when a constraint on MIDI velocity is respected. Used in conjunction with lovel , it makes the region play when the incoming note's velocity is equal to or higher than lovel and equal to or lower than hivel . Velocity is a MIDI value that indicates how forcefully the note is played. Opcode Prototype hivel = [upper limit] Parameter The mandatory [upper limit] parameter defines the range's upper limit. This parameter only accepts valid MIDI velocity values (from 0 to 127). Allowed Sections May be used in sections < global > and < region >. Examples Defines a snare instrument with three regions/velocity ranges: 0-70, 71-125 and 126-127 for the rim shot. < region > sample =mysamples/snare-soft.wav lovel =0 hivel =70 < region > sample =mysamples/snare-hard.wav lovel =71 hivel =125 < region > sample =mysamples/snare-rimshot.wav lovel =126 hivel =127 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hirand Opcode \u2191 SFZ File Format \u2192 key Opcode","title":"hivel Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/hivel/#opcode-prototype","text":"hivel = [upper limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/hivel/#parameter","text":"The mandatory [upper limit] parameter defines the range's upper limit. This parameter only accepts valid MIDI velocity values (from 0 to 127).","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/hivel/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/hivel/#examples","text":"Defines a snare instrument with three regions/velocity ranges: 0-70, 71-125 and 126-127 for the rim shot. < region > sample =mysamples/snare-soft.wav lovel =0 hivel =70 < region > sample =mysamples/snare-hard.wav lovel =71 hivel =125 < region > sample =mysamples/snare-rimshot.wav lovel =126 hivel =127","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/hivel/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hirand Opcode \u2191 SFZ File Format \u2192 key Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/key/","text":"With this opcode you can cause a region to be played only when the incoming MIDI note is equal to [note-value] . If you want your region to be triggered by a range of notes, please see lokey and hikey opcodes. Opcode Prototype key = [note-value] Parameter The mandatory [note-value] parameter defines the note assigned to the region. This parameter only accepts a valid MIDI note number (from 0 to 127) or name (from C-1 to G9): Note Numbers Note Names Octave 0 to 11 C-1 to B-1 -1 12 to 23 C0 to B0 0 24 to 35 C1 to B1 1 36 to 47 C2 to B2 2 48 to 59 C3 to B3 3 60 to 71 C4 to B4 4 72 to 83 C5 to B5 5 84 to 95 C6 to B6 6 96 to 107 C7 to B7 7 108 to 119 C8 to B8 8 120 to 127 C9 to G9 9 Allowed Sections May be used in sections < global > and < region >. Examples Defines one different note for every region. < region > sample =mysamples/piano-c1.wav key =24 < region > sample =mysamples/piano-c#1.wav key =25 < region > sample =mysamples/piano-d1.wav key =26 < region > sample =mysamples/piano-d#1.wav key =d#1 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hivel Opcode \u2191 SFZ File Format \u2192 lobend Opcode","title":"key Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/key/#opcode-prototype","text":"key = [note-value]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/key/#parameter","text":"The mandatory [note-value] parameter defines the note assigned to the region. This parameter only accepts a valid MIDI note number (from 0 to 127) or name (from C-1 to G9): Note Numbers Note Names Octave 0 to 11 C-1 to B-1 -1 12 to 23 C0 to B0 0 24 to 35 C1 to B1 1 36 to 47 C2 to B2 2 48 to 59 C3 to B3 3 60 to 71 C4 to B4 4 72 to 83 C5 to B5 5 84 to 95 C6 to B6 6 96 to 107 C7 to B7 7 108 to 119 C8 to B8 8 120 to 127 C9 to G9 9","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/key/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/key/#examples","text":"Defines one different note for every region. < region > sample =mysamples/piano-c1.wav key =24 < region > sample =mysamples/piano-c#1.wav key =25 < region > sample =mysamples/piano-d1.wav key =26 < region > sample =mysamples/piano-d#1.wav key =d#1","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/key/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 hivel Opcode \u2191 SFZ File Format \u2192 lobend Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/lobend/","text":"Causes the associated region to play when a constraint on MIDI pitch bend is respected. Used in conjunction with hibend , it makes the region play when the last pitch bend value received is equal to or higher than lobend and equal to or lower than hibend . Opcode Prototype lobend = [lower limit] Parameter The mandatory [lower limit] parameter defines the range's lower limit. This parameter only accepts valid MIDI pitch bend values (from -8192 to 8192). Allowed Sections May be used in sections < global > and < region >. Examples Defines a guitar instrument with two regions assigned to different position of the pitch bend wheel. < region > sample =mysamples/guitar-1.wav lobend =-5000 hibend =0 < region > sample =mysamples/guitar-2.wav lobend =1 hibend =5000 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 key Opcode \u2191 SFZ File Format \u2192 lochan Opcode","title":"lobend Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/lobend/#opcode-prototype","text":"lobend = [lower limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/lobend/#parameter","text":"The mandatory [lower limit] parameter defines the range's lower limit. This parameter only accepts valid MIDI pitch bend values (from -8192 to 8192).","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/lobend/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/lobend/#examples","text":"Defines a guitar instrument with two regions assigned to different position of the pitch bend wheel. < region > sample =mysamples/guitar-1.wav lobend =-5000 hibend =0 < region > sample =mysamples/guitar-2.wav lobend =1 hibend =5000","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/lobend/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 key Opcode \u2191 SFZ File Format \u2192 lochan Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/lochan/","text":"Causes the associated region to play when a constraint on MIDI channel is respected. Used in conjunction with hichan , it makes the region play when the incoming note's MIDI channel is equal to or higher than lochan and equal to or lower than hichan . Opcode Prototype lochan = [lower limit] Parameter The mandatory [lower limit] parameter defines the range's lower limit. This parameter only accepts valid MIDI channel numbers (from 1 to 16). Allowed Sections May be used in sections < global > and < region >. Examples A region triggered only by notes on MIDI channel 1. < region > sample =mysamples/piano_C1.wav lochan =1 hichan =1 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lobend Opcode \u2191 SFZ File Format \u2192 lokey Opcode","title":"lochan Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/lochan/#opcode-prototype","text":"lochan = [lower limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/lochan/#parameter","text":"The mandatory [lower limit] parameter defines the range's lower limit. This parameter only accepts valid MIDI channel numbers (from 1 to 16).","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/lochan/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/lochan/#examples","text":"A region triggered only by notes on MIDI channel 1. < region > sample =mysamples/piano_C1.wav lochan =1 hichan =1","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/lochan/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lobend Opcode \u2191 SFZ File Format \u2192 lokey Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/lokey/","text":"Causes the associated region to play when a constraint on MIDI note is respected. Used in conjunction with hikey , it makes the region play when the incoming note is equal to or higher than lokey and equal to or lower than hikey . Opcode Prototype lokey = [lower limit] Parameter The mandatory [lower limit] parameter defines the range's lower limit. This parameter only accepts valid MIDI note numbers (from 0 to 127) or names (from C-1 to G9): Note Numbers Note Names Octave 0 to 11 C-1 to B-1 -1 12 to 23 C0 to B0 0 24 to 35 C1 to B1 1 36 to 47 C2 to B2 2 48 to 59 C3 to B3 3 60 to 71 C4 to B4 4 72 to 83 C5 to B5 5 84 to 95 C6 to B6 6 96 to 107 C7 to B7 7 108 to 119 C8 to B8 8 120 to 127 C9 to G9 9 Allowed Sections May be used in sections < global > and < region >. Examples Defines one region for each of three octaves. < region > sample =mysamples/octave01.wav lokey =24 hikey =35 < region > sample =mysamples/octave02.wav lokey =C2 hikey =B2 < region > sample =mysamples/octave03.wav lokey =48 hikey =59 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lochan Opcode \u2191 SFZ File Format \u2192 lorand Opcode","title":"lokey Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/lokey/#opcode-prototype","text":"lokey = [lower limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/lokey/#parameter","text":"The mandatory [lower limit] parameter defines the range's lower limit. This parameter only accepts valid MIDI note numbers (from 0 to 127) or names (from C-1 to G9): Note Numbers Note Names Octave 0 to 11 C-1 to B-1 -1 12 to 23 C0 to B0 0 24 to 35 C1 to B1 1 36 to 47 C2 to B2 2 48 to 59 C3 to B3 3 60 to 71 C4 to B4 4 72 to 83 C5 to B5 5 84 to 95 C6 to B6 6 96 to 107 C7 to B7 7 108 to 119 C8 to B8 8 120 to 127 C9 to G9 9","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/lokey/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/lokey/#examples","text":"Defines one region for each of three octaves. < region > sample =mysamples/octave01.wav lokey =24 hikey =35 < region > sample =mysamples/octave02.wav lokey =C2 hikey =B2 < region > sample =mysamples/octave03.wav lokey =48 hikey =59","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/lokey/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lochan Opcode \u2191 SFZ File Format \u2192 lorand Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/lorand/","text":"Causes the associated region to play when a generated random number is between a defined range. Used in conjunction with hirand , it makes the region play when the value of a random number generated by a note-on event is equal to or higher than lorand and lower than hirand . Opcode Prototype lorand = [lower limit] Parameter The mandatory [lower limit] parameter defines the range's lower limit. The accepted values for this parameter are in the 0-1 range. Allowed Sections May be used in section < region >. Examples Sets a pool of four clap samples, one of them is randomly choosen at every note-on event. < region > sample =mysamples/clap_01.wav lorand =0 hirand =0.250 < region > sample =mysamples/clap_02.wav lorand =0.250 hirand =0.500 < region > sample =mysamples/clap_03.wav lorand =0.500 hirand =0.750 < region > sample =mysamples/clap_04.wav lorand =0.750 hirand =1 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lokey Opcode \u2191 SFZ File Format \u2192 lovel Opcode","title":"lorand Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/lorand/#opcode-prototype","text":"lorand = [lower limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/lorand/#parameter","text":"The mandatory [lower limit] parameter defines the range's lower limit. The accepted values for this parameter are in the 0-1 range.","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/lorand/#allowed-sections","text":"May be used in section < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/lorand/#examples","text":"Sets a pool of four clap samples, one of them is randomly choosen at every note-on event. < region > sample =mysamples/clap_01.wav lorand =0 hirand =0.250 < region > sample =mysamples/clap_02.wav lorand =0.250 hirand =0.500 < region > sample =mysamples/clap_03.wav lorand =0.500 hirand =0.750 < region > sample =mysamples/clap_04.wav lorand =0.750 hirand =1","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/lorand/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lokey Opcode \u2191 SFZ File Format \u2192 lovel Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/lovel/","text":"Causes the associated region to play when a constraint on MIDI velocity is respected. Used in conjunction with hivel , it makes the region play when the incoming note's velocity is equal to or higher than lovel and equal to or lower than hivel . Velocity is a MIDI value that indicates how forcefully the note is played. Opcode Prototype lovel = [lower limit] Parameter The mandatory [lower limit] parameter defines the range's lower limit. This parameter only accepts valid MIDI velocity values (from 0 to 127). Allowed Sections May be used in sections < global > and < region >. Examples Sets a pool of four clap samples, one of them is randomly choosen at every note-on event. < region > sample =mysamples/snare-soft.wav lovel =0 hivel =70 < region > sample =mysamples/snare-hard.wav lovel =71 hivel =125 < region > sample =mysamples/snare-rimshot.wav lovel =126 hivel =127 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lorand Opcode \u2191 SFZ File Format \u2192 sample Opcode","title":"lovel Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/lovel/#opcode-prototype","text":"lovel = [lower limit]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/lovel/#parameter","text":"The mandatory [lower limit] parameter defines the range's lower limit. This parameter only accepts valid MIDI velocity values (from 0 to 127).","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/lovel/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/lovel/#examples","text":"Sets a pool of four clap samples, one of them is randomly choosen at every note-on event. < region > sample =mysamples/snare-soft.wav lovel =0 hivel =70 < region > sample =mysamples/snare-hard.wav lovel =71 hivel =125 < region > sample =mysamples/snare-rimshot.wav lovel =126 hivel =127","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/lovel/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lorand Opcode \u2191 SFZ File Format \u2192 sample Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/sample/","text":"This is the most fundamental opcode of the SFZ file format. It allows you to load and assign a certain audio sample file. A variety of audio file formats are supported. Opcode Prototype sample = [path] Parameter The mandatory [path] parameter defines the file system path of the sample file that shall be loaded and assigned, which may either be an absolute path or a relative path. A relative path is always interpreted relative to the sfz file's location. Allowed Sections May be used in sections < global > and < region >, ... TODO. Examples Loads the WAV file \"organ_c3.wav\" from the subdirectory \"mysamples\" and assigns it to the entire key range of the instrument. < global > sample =mysamples/organ_c3.wav Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lovel Opcode \u2191 SFZ File Format \u2192 script Opcode","title":"sample Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/sample/#opcode-prototype","text":"sample = [path]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/sample/#parameter","text":"The mandatory [path] parameter defines the file system path of the sample file that shall be loaded and assigned, which may either be an absolute path or a relative path. A relative path is always interpreted relative to the sfz file's location.","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/sample/#allowed-sections","text":"May be used in sections < global > and < region >, ... TODO.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/sample/#examples","text":"Loads the WAV file \"organ_c3.wav\" from the subdirectory \"mysamples\" and assigns it to the entire key range of the instrument. < global > sample =mysamples/organ_c3.wav","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/sample/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 lovel Opcode \u2191 SFZ File Format \u2192 script Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/script/","text":"This is an extension to the SFZ file format which is currently only available with LinuxSampler. It allows to load real-time instrument scripts for SFZ instruments. Find out more about Instrument Scripts . Opcode Prototype script = [path] Parameter The mandatory [path] parameter defines the file system path to the real-time instrument script file that shall be loaded and executed, which may either be an absolute path or a relative path. A relative path is always interpreted relative to the sfz file's location. Allowed Sections May be used in < global > section. Examples Loads the WAV file \"some_sound.wav\" and assigns it to the entire key range of the instrument, and loads the real-time instrument script file \"my_nksp_script.txt\" from the subdirectory \"myscripts\". The script will be executed on the respective events the script file provides event handlers for. < global > script =myscripts/my_nksp_script.txt < group > sample =mysamples/some_sound.wav Availability Since LinuxSampler 2.0.0.svn37 Extension, not available with any SFZ standard. \u2190 sample Opcode \u2191 SFZ File Format \u2192 seq_length Opcode","title":"script Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/script/#opcode-prototype","text":"script = [path]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/script/#parameter","text":"The mandatory [path] parameter defines the file system path to the real-time instrument script file that shall be loaded and executed, which may either be an absolute path or a relative path. A relative path is always interpreted relative to the sfz file's location.","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/script/#allowed-sections","text":"May be used in < global > section.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/script/#examples","text":"Loads the WAV file \"some_sound.wav\" and assigns it to the entire key range of the instrument, and loads the real-time instrument script file \"my_nksp_script.txt\" from the subdirectory \"myscripts\". The script will be executed on the respective events the script file provides event handlers for. < global > script =myscripts/my_nksp_script.txt < group > sample =mysamples/some_sound.wav","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/script/#availability","text":"Since LinuxSampler 2.0.0.svn37 Extension, not available with any SFZ standard. \u2190 sample Opcode \u2191 SFZ File Format \u2192 seq_length Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_length/","text":"Used in conjunction with seq_position , it defines the length of a sequence. Opcode Prototype seq_length = [length] Parameter The mandatory [length] defines the length of a sequence. Allowed Sections May be used in < region > section. Examples Sets the region as the 3rd step in a sequence of six elements. < group > seq_length =6 seq_position =3 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 script Opcode \u2191 SFZ File Format \u2192 seq_position Opcode","title":"seq_length Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_length/#opcode-prototype","text":"seq_length = [length]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_length/#parameter","text":"The mandatory [length] defines the length of a sequence.","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_length/#allowed-sections","text":"May be used in < region > section.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_length/#examples","text":"Sets the region as the 3rd step in a sequence of six elements. < group > seq_length =6 seq_position =3","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_length/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 script Opcode \u2191 SFZ File Format \u2192 seq_position Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_position/","text":"Used in conjunction with seq_length , it makes the region play when the internal sequence counter is equal to seq_position value. Opcode Prototype seq_position = [position] Parameter The mandatory [position] parameter defines the region's position in a sequence. Allowed Sections May be used in < region > section. Examples Sets the region as the 3rd step in a sequence of six elements. < group > seq_length =6 seq_position =3 Sets a sequence of three snare samples. < region > sample =mysamples/snare_01.wav seq_length =3 seq_position =1 < region > sample =mysamples/snare_02.wav seq_length =3 seq_position =2 < region > sample =mysamples/snare_03.wav seq_length =3 seq_position =3 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 seq_length Opcode \u2191 SFZ File Format \u2192 set_ccN Opcode","title":"seq_position Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_position/#opcode-prototype","text":"seq_position = [position]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_position/#parameter","text":"The mandatory [position] parameter defines the region's position in a sequence.","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_position/#allowed-sections","text":"May be used in < region > section.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_position/#examples","text":"Sets the region as the 3rd step in a sequence of six elements. < group > seq_length =6 seq_position =3 Sets a sequence of three snare samples. < region > sample =mysamples/snare_01.wav seq_length =3 seq_position =1 < region > sample =mysamples/snare_02.wav seq_length =3 seq_position =2 < region > sample =mysamples/snare_03.wav seq_length =3 seq_position =3","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/seq_position/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 seq_length Opcode \u2191 SFZ File Format \u2192 set_ccN Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/set_ccn/","text":"Sets a different initial MIDI controller value to the requested MIDI controller. Opcode Prototype set_cc [N] = [value] Parameter Parameter Name Description N Defines the MIDI controller which should be altered. [required] value Defines the MIDI controller's new initial value (0-127). [required] Allowed Sections Should be used in < control > section. Examples Sets the so called \"MIDI Expression Controller\" (MIDI CC #11) to its maximum value (127). < control > set_cc11 =127 Availability Since LinuxSampler 2.0.0.svn41 Conforms to SFZ v2 Standard. \u2190 seq_position Opcode \u2191 SFZ File Format \u2192 transpose Opcode","title":"set_ccN Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/set_ccn/#opcode-prototype","text":"set_cc [N] = [value]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/set_ccn/#parameter","text":"Parameter Name Description N Defines the MIDI controller which should be altered. [required] value Defines the MIDI controller's new initial value (0-127). [required]","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/set_ccn/#allowed-sections","text":"Should be used in < control > section.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/set_ccn/#examples","text":"Sets the so called \"MIDI Expression Controller\" (MIDI CC #11) to its maximum value (127). < control > set_cc11 =127","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/set_ccn/#availability","text":"Since LinuxSampler 2.0.0.svn41 Conforms to SFZ v2 Standard. \u2190 seq_position Opcode \u2191 SFZ File Format \u2192 transpose Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/transpose/","text":"With this opcode you can change the original pitch of the sample, increasing or decreasing it within the range of +-127 semitones. If you want to increase or decrease the pitch within a semitone, please see the tune opcode. Opcode Prototype transpose = [semitones] Parameter The mandatory [semitones] parameter defines the amount of pitch shifting. This parameter accepts values from -127 to 127. Allowed Sections May be used in sections < global > and < region >. Examples Create the first four semitones of a piano octave using only one sample. < group > sample =mysamples/piano-c1.wav < region > key =24 < region > key =25 transpose =1 < region > key =26 transpose =2 < region > key =27 transpose =3 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 set_ccN Opcode \u2191 SFZ File Format \u2192 tune Opcode","title":"transpose Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/transpose/#opcode-prototype","text":"transpose = [semitones]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/transpose/#parameter","text":"The mandatory [semitones] parameter defines the amount of pitch shifting. This parameter accepts values from -127 to 127.","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/transpose/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/transpose/#examples","text":"Create the first four semitones of a piano octave using only one sample. < group > sample =mysamples/piano-c1.wav < region > key =24 < region > key =25 transpose =1 < region > key =26 transpose =2 < region > key =27 transpose =3","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/transpose/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 set_ccN Opcode \u2191 SFZ File Format \u2192 tune Opcode","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/opcode/tune/","text":"With this opcode you can fine tune the sample played. You can change the original pitch of the sample, increasing or decreasing it within the range of +-100 cents. If you want to increase or decrease the pitch to more than a semitone, please see the transpose opcode. Opcode Prototype tune = [cents] Parameter The mandatory [cents] parameter defines the amount of pitch shifting. This parameter accepts values from -100 to 100. Allowed Sections May be used in sections < global > and < region >. Examples Adjusts the pitch of a sample in a region. < region > sample =mysamples/piano-c2-out_of_tune.wav tune =50 Availability Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 transpose Opcode \u2191 SFZ File Format","title":"tune Opcode"},{"location":"en/linuxsampler/docs/sfz/opcode/tune/#opcode-prototype","text":"tune = [cents]","title":"Opcode Prototype"},{"location":"en/linuxsampler/docs/sfz/opcode/tune/#parameter","text":"The mandatory [cents] parameter defines the amount of pitch shifting. This parameter accepts values from -100 to 100.","title":"Parameter"},{"location":"en/linuxsampler/docs/sfz/opcode/tune/#allowed-sections","text":"May be used in sections < global > and < region >.","title":"Allowed Sections"},{"location":"en/linuxsampler/docs/sfz/opcode/tune/#examples","text":"Adjusts the pitch of a sample in a region. < region > sample =mysamples/piano-c2-out_of_tune.wav tune =50","title":"Examples"},{"location":"en/linuxsampler/docs/sfz/opcode/tune/#availability","text":"Since LinuxSampler 2.0.0 Conforms to SFZ v1 Standard. \u2190 transpose Opcode \u2191 SFZ File Format","title":"Availability"},{"location":"en/linuxsampler/docs/sfz/section/global/","text":"Statements in this section shall apply to the entire SFZ instrument. In practice you may use this section to place articulation settings which should fit for most of the part of your instrument. For example you may assign certain envelope settings in the < global > section of your instrument's sfz file and if you need a certain other envelope setting at a certain key or key range, you may override this default envelope setting with a < group > section or < region > section. \u2191 SFZ File Format","title":"SFZ Global section"},{"location":"en/linuxsampler/sfz/","text":"Last update: 3 June, 2012. Table of Contents LinuxSampler SFZ Implementation Introduction Structure Region Group Global Control Curve Effects Comments Units MIDI Continuous Controller Modulation Additional Controllers Table 1.1 Sample Definition Table 1.2 Control Table 1.3 Loading Table 1.4 Wavetable Oscillator Table 1.5 Input Controls Table 1.6 Sample Player Table 1.7 Amplifier Table 1.8 Pitch Table 1.9 Filter Table 1.10 Envelope Generators Table 1.11 Low-Frequency Oscillators Table 1.12 Equalizer Table 1.13 Effects (SFZ v2) Table 1.14 Effects (SFZ v1) Table 1.15 Amplifier EG (SFZ v1) Table 1.16 Amplifier LFO (SFZ v1) Table 1.17 Filter EG (SFZ v1) Table 1.18 Filter LFO (SFZ v1) Table 1.19 Pitch EG (SFZ v1) Table 1.20 Pitch LFO (SFZ v1) Table 1.21 Curve Table 1.22 Global This is a work in progress! Introduction SFZ is a file format to define how a collection of samples and other type of oscillators are arranged for performance. The goal behind the SFZ format is to provide a free, simple, minimalistic and expandable format to arrange, distribute and use audio samples with the highest possible quality and the highest possible performance flexibility. Soundware, software and hardware developers can create, use and distribute the SFZ format files for free, for either free or commercial applications. The following is an overview of the implementation of SFZ in LinuxSampler. It will serve as a chart of the state of our implementation. The numbering of tables (up to 1.20) correspond to Cakewalk Synthesizers Appendix A . Some opcodes introduced by Garritan/Plogue in their ARIA engine have been included. Missing and otherwise omitted opcodes have also been added to the tables by us. This document represents LinuxSamplers interpretation of the SFZ format and is not guaranteed to be correct in any way, shape or form. ~~Stricken~~ opcodes in tables are not implemented by LinuxSampler at this time. All opcodes are in lower case, capitalized N , X and Y in opcode names indicate an integer number. Structure An instrument in the SFZ format is a collection of sample files and a SFZ definition file. A SFZ definition file contain two types of tokens: headers and opcodes . Headers starts with a lesser-than character (<) and ends with a greater-than character (>). Opcodes are key/value pairs separated by an equal to sign (=). The opcode values can either be integers, floating point numbers or strings. Region An instrument is defined as a collection of regions. A region include the definition for the input controls (when and how the region will be triggered for playback), the samples to be played and the performance parameters (how to play those samples). A region starts with the <region> header and is followed by one or more opcodes. Group Regions can be arranged into groups. Groups allow entering common parameters for multiple regions, think of it as a template for regions. A group start with the <group> header and is followed by one or more opcodes. Global Global settings applying to the whole SFZ definition file can be defined. Think of it as a template for all groups and regions. Some opcodes can only be set here. The global settings start with the <global> header and is followed by one or more opcodes (see Table 1.22 ). Control Control directives are used to specify a default path to the location of samples or set the default position for any MIDI continuous controller. Those are special opcodes that can only be set here. The control settings start with the <control> header and is followed by one or more opcodes (see Table 1.2 ). Curve The player define up to six curves internally but additional custom curves can also be defined. A custom curve start with the <curve> header and is followed by one or more curve value opcodes (see Table 1.21 ). Effects Effects that should apply to all voices can be defined. Effects start with the <effects> header and is followed by one or more effect opcodes (see Table 1.13 ). Comments Comment lines can be inserted anywhere inside the file. A comment line starts with two slash characters ('//') and it extends until the end of the line. Units All units in the SFZ format are in real-world values. Frequencies are expressed in Hertz , pitches in cents , amplitudes in percentage and volumes in decibels . Notes are expressed in MIDI Note Numbers, or in note names according to the International Pitch Notation (IPN) convention. According to this rules, middle C in the keyboard is C4 and the MIDI note number 60. MIDI Continuous Controller Modulation Everything that can be modulated by a continuous controller has a _oncc opcode suffix. A _smoothcc suffix sets the speed of parameter change in milliseconds. A _stepcc sets in what steps the parameter change is introduced. A _curvecc suffix sets the curve defined in the file. Additional Controllers SFZ support an extended set of MIDI CC messages generated by the various Cakewalk synthesizers GUIs. Events for the following CC numbers are generated by other MIDI events or internal generators and therefore might be applicable to our implementation: 128: bend 129: channel aftertouch 130: polyphonic aftertouch 131: velocity 132: release velocity 133: keyboard (noye 0=0, note 127=1) 134: key gate (0 if no keys are pressed, 1 otherwise) 135: random (0 to 1) 136: random (-1 to 1) 137: alternate (changes from 0 to 1 and vice versa) Table 1.1 Sample Definition | Opcode | Description | Type | Range | ---------------- | ----------- | ---- | | sample= | This opcode defines which sample file the region will play. The value of this opcode is the filename of the sample file, including the extension. The filename must be stored in the same folder where the definition file is, or specified relatively to it. If the sample file is not found, the player will ignore the whole region contents. Long names and names with blank spaces and other special characters (excepting the = character) are allowed in the sample definition. The sample file can either be a WAVE, AIFF or OGG file. | string | n/a | | ~~ md5= ~~ | ~~Verifies the MD5 hash of a sample on loading.~~ | ~~string~~ | ~~n/a~~ | ~~ waveguide= ~~ | ~~Instructs the player to treat the loaded sample as an impulse which is directed to a waveguide.~~ | ~~string~~ | ~~on off~~ Table 1.2 Control There can be multiple <control> headers in a file. Their effects lasts until the end of the file or the next <control> header. Opcode Description Type Range default_path= This defines a default path, which will be added to every path in the sample opcode. string n/a octave_offset= This opcode sets an offset which will be applied to all note names and numbers in a definition. integer n/a note_offset= Shifts all notes in a given map. integer n/a set_ccN= Sets the named MIDI CC initial value. integer 0 to 127 ~~ #define ~~ ~~Allows for macro/text pre-processing~~ ~~string~~ ~~n/a~~ Table 1.3 Loading Opcode Description Type Range ~~ load_mode= ~~ ~~Similar to \"load mode\" in Dimension Pro, but on a per-region basis. 0 : load as 32-bit 1 : load as 16-bit~~ ~~integer~~ ~~0 to 1~~ ~~ load_start= ~~ ~~ load_end= ~~ ~~Allows loading only part of a sample into memory.~~ ~~integer~~ ~~0 to 4294967296~~ ~~ sample_quality= ~~ ~~Sets the quality for sample-playback. 1 : linear 2 : high 3-10 : different sinc interpolated modes~~ ~~integer~~ ~~1 to 10~~ ~~ image= ~~ ~~Allows loading a BMP image, with or without alpha-channel for display purposes.~~ ~~string~~ ~~n/a~~ Table 1.4 Wavetable Oscillator Opcode Description Type Range ~~ oscillator= ~~ ~~If the value is set to on, the region becomes a wavetable oscillator. The sample specified in the region will be used to extract the spectral information and construct the wavetable.~~ ~~string~~ ~~on, off~~ ~~ oscillator_phase= ~~ ~~Sets the initial phase for the oscillator, from 0 to 360 degrees. A negative value will make the oscillator start at a random phase.~~ ~~integer~~ ~~-360 to 360 degrees~~ ~~ oscillator_quality= ~~ ~~Sets the quality for wavetable playback. 0 : nearest 1 : linear 2 : high 3 : dual-high~~ ~~integer~~ ~~0 to 3~~ ~~ oscillator_table_size= ~~ ~~Defines the table size of the wavetable used for the oscillator playback.~~ ~~integer~~ ~~0 to 4294967296~~ ~~ oscillator_multi= ~~ ~~Sets the oscillator to play in multi mode. When oscillator_mode=0 1 : engage a single oscillator 2 : engage ring modulation~~ ~~integer~~ ~~3 to 9~~ ~~ oscillator_mode= ~~ ~~Defines the playback mode for the oscillator. 0 : normal and ring modulation 1 : phase modulation 2 : frequency modulation~~ ~~integer~~ ~~0 to 2~~ ~~ oscillator_detune= ~~ ~~Sets the detune between the oscillators when in Multi, Ring, PM or FM modes.~~ ~~integer~~ ~~-100 to 100 cents~~ ~~ oscillator_detune_onccN= ~~ ~~Sets the detune between the oscillators modulated by MIDI continuous controller N.~~ ~~integer~~ ~~-100 to 100 cents~~ ~~ oscillator_mod_depth= ~~ ~~Sets the depth of modulation in PM/FM modes.~~ ~~integer~~ ~~-1200 to 1200 cents~~ ~~ oscillator_mod_depth_onccN= ~~ ~~Sets the depth of modulation in PM/FM modes modulated by MIDI continuous controller N.~~ ~~integer~~ ~~-1200 to 1200 cents~~ ~~ oscillator_mod_smoothcc= ~~ ~~Sets the control smooth for the depth of modulation when in PM/FM modes.~~ Table 1.5 Input Controls The input controls define the conditions under which a region will get triggered and play back. Some input control states are defined at the instrument level while others (timer, sequence, key switches and groups) are defined at the region level. A region can be triggered by either a key or controller. The key and velocity will be used if triggered by a key. The controller number and value will be used if triggered by a controller. Opcode Description Type Range lochan= hichan= If incoming notes have a MIDI channel between lochan and hichan , the region will play. integer 1 to 16 lokey= hikey= key= If a note equal to or higher than lokey AND equal to or lower than hikey is played, the region will play. integer 0 to 127 lovel= hivel= If a note with velocity value equal to or higher than lovel AND equal to or lower than hivel is played, the region will play. integer 0 to 127 loccN= hiccN= Defines the range of the last MIDI controller N required for the region to play. integer 0 to 127 lobend= hibend= Defines the range of the last Pitch Bend message required for the region to play. integer -8192 to 8192 lobpm= hibpm= Host tempo value. The region will play if the host tempo is equal to or higher than lobpm , and lower than hibpm . integer 0 to 500 lochanaft= hichanaft= Defines the range of last Channel Aftertouch message required for the region to play. integer 0 to 127 lopolyaft= hipolyaft= Defines the range of last Polyphonic Aftertouch message required for the region to play. integer 0 to 127 loprog= hiprog= Sets a region playback based on the value of the last Program Change message recieved. integer 0 to 127 lorand= hirand= Random values. The player will generate a new random number on every note-on event, in the range 0~1. The region will play if the random number is equal to or higher than lorand , and lower than hirand . float 0 to 1 lotimer= hitimer= Set the region to play if the specified time has elapsed since a region in the same group has played. float n/a ~~ reverse_loccN= ~~ ~~ reverse_hiccN= ~~ ~~Sets the region into reverse playback based on a CC.~~ ~~integer~~ ~~0 to 127~~ seq_length= Sequence length. The player will keep an internal counter creating a consecutive note-on sequence for each region, starting at 1 and resetting at seq_length . integer 1 to 100 seq_position= Sequence position. The region will play if the internal sequence counter is equal to seq_position . integer 1 to 100 start_loccN= start_hiccN= stop_loccN= stop_hiccN= Defines a range of values to start a region playback, and another range of values of a control to stop the region playback (as replacements for note-on and note-off messages). integer 0 to 127 sw_lokey= sw_hikey= Defines the range of the keyboard to be used as trigger selectors for the sw_last opcode. integer 0 to 127 sw_last= Enables the region to play if the last key pressed in the range specified by sw_lokey and sw_hikey is equal to the sw_last value. integer 0 to 127 sw_down= Enables the region to play if the key equal to sw_down value is depressed. Key has to be in the range specified by sw_lokey and sw_hikey . integer 0 to 127 sw_up= Enables the region to play if the key equal to sw_up value is not depressed. Key has to be in the range specified by sw_lokey and sw_hikey . integer 0 to 127 sw_previous= Previous note value. The region will play if last note-on message was equal to sw_previous value. integer 0 to 127 sw_vel= This opcode allows overriding the velocity for the region with the velocity of the previous note. Values can be: current : Region uses the velocity of current note. previous : Region uses the velocity of the previous note. string current, previous trigger= Sets the trigger which will be used for the sample to play. Values can be: attack (default): Region will play on note-on. release : Region will play on note-off. The velocity used to play the note-off sample is the velocity value of the corresponding (previous) note-on message. first : Region will play on note-on, but if there's no other note going on (staccato, or first note in a legato phrase). legato : Region will play on note-on, but only if there's a note going on (notes after first note in a legato phrase). string attack, release, first, legato group= Exclusive group number for this region. integer 0 to 4294967296 off_by= Region off group. When a new region with a group number equal to off_by plays, this region will be turned off. integer 0 to 4294967296 off_mode= Region off mode. This opcode will determinate how a region is turned off by an off_by opcode. Values can be: fast (default): The voice will be turned off immediately. Release settings will not have any effect. normal : The region will be set into release stage. All envelope generators will enter in release stage, and region will expire when the amplifier envelope generator expired. string fast, normal on_loccN= on_hiccN= Sample trigger on MIDI continuous control N. If a MIDI control message with a value between on_loccN and on_hiccN is received, the region will play. integer 0 to 127 Table 1.6 Sample Player Opcode Description Type Range count= The number of times the sample will be played. If this opcode is specified, the sample will restart as many times as defined. Envelope generators will not be retriggered on sample restart. When this opcode is defined, loopmode is automatically set to one_shot . integer 0 to 4294967296 delay= Region delay time, in seconds. If a delay value is specified, the region playback will be postponed for the specified time. If the region receives a note-off message before delay time, the region won't play. All envelope generators delay stage will start counting after region delay time. float 0 to 100 seconds delay_onccN= Region delay time modulated by MIDI continuous controller N, in seconds. If the region receives a note-off message before delay time, the region won't play. All envelope generators delay stage will start counting after region delay time. float 0 to 100 seconds delay_random= Region random delay time, in seconds. If the region receives a note-off message before delay time, the region won't play. float 0 to 100 seconds delay_beats= stop_beats= Specify a region delay, or time-to-stop in beats, synchronized to host tempo. integer 0 to 32 beats delay_samples= delay_samples_onccN= Allows specifying a delay for a given region in samples (independent of sample rate). integer 0 to 4294967296 end= The endpoint of the sample, in sample units. The player will reproduce the whole sample if end is not specified. If end value is -1, the sample will not play. Marking a region end with -1 can be used to use a silent region to turn off other regions by using the group and off_by opcodes. integer -1 to 4294967296 loop_crossfade= Set a value for loop crossfading, in seconds. float 0 to 100 seconds offset= The offset used to play the sample, in sample units. The player will reproduce samples starting with the very first sample in the file, unless offset is specified. It will start playing the file at the offset sample in this case. integer 0 to 4294967296 offset_random= Random offset added to the region offset, in sample units. integer 0 to 4294967296 offset_onccN= The offset used to play the sample according to last position of MIDI continuous controller N, in sample units. integer 0 to 4294967296 loop_mode= If loop_mode is not specified, each sample will play according to its predefined loop mode. That is, the player will play the sample looped using the first defined loop, if available. If no loops are defined, the wave will play unlooped. The loop_mode opcode allows playing samples with loops defined in the unlooped mode. The possible values are: no_loop : no looping will be performed. Sample will play straight from start to end, or until note off, whatever reaches first. (Default for samples without a loop defined.) one_shot : sample will play from start to end, ignoring note off. This mode is engaged automatically if the count opcode is defined. loop_continuous : once the player reaches sample loop point, the loop will play until note expiration. loop_sustain : the player will play the loop while the note is held, by keeping it depressed or by using the sustain pedal (CC64). The rest of the sample will play after note release. (Default for samples with defined loop(s).) string no_loop, one_shot, loop_continuous, loop_sustain loop_start= The loop start point, in samples. If loop_start is not specified and the sample has a loop defined, the sample start point will be used. If loop_start is specified, it will overwrite the loop start point defined in the sample. This opcode will not have any effect if loopmode is set to no_loop . integer 0 to 4294967296 loop_end= The loop end point, in samples. This opcode will not have any effect if loopmode is set to no_loop . If loop_end is not specified and the sample have a loop defined, the sample loop end point will be used. If loop_end is specified, it will overwrite the loop end point defined in the sample. integer 0 to 4294967296 sync_beats= Region playing synchronization to host position. When sync_beats is specified and after input controls instruct the region to play, the playback will be postponed until the next multiple of the specified value is crossed. integer 0 to 32 beats sync_offset= Region playing synchronization to host position offset. When sync_beats is specified and after input controls instruct the region to play, the playback will be postponed until the next multiple of the specified value plus the sync_offset value is crossed. integer 0 to 32 beats Table 1.7 Amplifier Opcode Description Type Range volume= The volume for the region, in dB. float -144 to 6 dB volume_onccN= volume_smoothccN= volume_curveccN= amplitude= The amplitude for the region, in percent. float 0 to 100 % amplitude_onccN= amplitude_smoothccN= amplitude_curveccN= pan= The panoramic position for the region, in percent. If a mono sample is used, pan value defines the position in the stereo image where the sample will be placed. When a stereo sample is used, the pan value the relative amplitude of one channel respect the other. A value of zero means centered, negative values move the panoramic to the left, positive to the right. float -100 to 100 % pan_onccN= pan_smoothccN= pan_curveccN= pan_law= string no_law width= Only operational for stereo samples, width defines the amount of channel mixing applied to play the sample. A width value of 0 makes a stereo sample play as if it were mono (adding both channels and compensating for the resulting volume change). A value of 100 will make the stereo sample play as original. Any value in between will mix left and right channels with a part of the other, resulting in a narrower stereo field image. Negative width values will reverse left and right channels. float -100 to 100 % width_onccN= width_smoothccN= width_curveccN= position= Only operational for stereo samples, positionwidth opcode. defines the position in the stereo field of a stereo signal, after channel mixing as defined in the A value of zero means centered, negative values move the panoramic to the left, positive to the right. float -100 to 100 % position_onccN= position_smoothccN= position_curveccN= amp_keytrack= Amplifier keyboard tracking (change in amplitude per key) in dB. float -96 to 12 dB amp_keycenter= Center key for amplifier keyboard tracking. In this key, the amplifier keyboard tracking will have no effect. integer 0 to 127 amp_veltrack= Amplifier velocity tracking, represents how much the amplitude changes with incoming note velocity. Volume changes with incoming velocity in a concave shape according to the following expression: Amplitude(dB) = 20 log (127^2 / Velocity^2) The amp_velcurve_N opcodes allow overriding the default velocity curve. float -100 to 100 % amp_velcurve_N= User-defined amplifier velocity curve. This opcode range allows defining a specific curve for the amplifier velocity. The value of the opcode indicates the normalized amplitude (0 to 1) for the specified velocity. float 0 to 1 amp_random= Random volume for the region, in dB. float 0 to 24 dB rt_decay= The volume decay amount when the region is set to play in release trigger mode, in decibels per second since note-on message. float 0 to 200 dB output= The stereo output number for this region. If the player doesn't feature multiple outputs, this opcode is ignored. n/a 0 to 1024 gain_onccN= Gain applied on MIDI control N, in dB. float -144 to 48 dB gain_smoothccN= gain_curveccN= xfin_lokey= xfin_hikey= Fade in control. xfin_lokey and xfin_hikey define the fade-in keyboard zone for the region. The volume of the region will be zero for keys lower than or equal to xfin_lokey, and maximum (as defined by the volume opcode) for keys greater than or equal to xfin_hikey. integer 0 to 127 xfout_lokey= xfout_hikey= Fade out control. xfout_lokey and xfout_hikey define the fade-out keyboard zone for the region. The volume of the region will be maximum (as defined by the volume opcode) for keys lower than or equal to xfout_lokey, and zero for keys greater than or equal to xfout_hikey. integer 0 to 127 xf_keycurve= Keyboard crossfade curve for the region. Values can be: gain: Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power: Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade. string gain, power xfin_lovel= xfin_hivel= Fade in control. xfin_lovel and xfin_hivel define the fade-in velocity range for the region. The volume of the region will be zero for velocities lower than or equal to xfin_lovel, and maximum (as defined by the volume opcode) for velocities greater than or equal to xfin_hivel. integer 0 to 127 xfout_lovel= xfout_hivel= Fade out control. xfout_lokey and xfout_hikey define the fade-out velocity range for the region. The volume of the region will be maximum (as defined by the volume opcode) for velocities lower than or equal to xfout_lovel, and zero for velocities greater than or equal to xfout_hivel. integer 0 to 127 xf_velcurve= Velocity crossfade curve for the region. Values can be: gain: Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power: Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade. string gain, power xfin_loccN= xfin_hiccN= Fade in control. xfin_loccN and xfin_hiccN set the range of values in the MIDI continuous controller N which will perform a fade-in in the region. The volume of the region will be zero for values of the MIDI continuous controller N lower than or equal to xfin_loccN, and maximum (as defined by the volume opcode) for values greater than or equal to xfin_hiccN. integer 0 to 127 xfout_loccN= xfout_hiccN= Fade out control. xfout_loccN and xfout_hiccN set the range of values in the MIDI continuous controller N which will perform a fade-out in the region. The volume of the region will be maximum (as defined by the volume opcode) for values of the MIDI continuous controller N lower than or equal to xfout_loccN, and zero for values greater than or equal to xfout_hiccN. integer 0 to 127 xf_cccurve= MIDI controllers crossfade curve for the region. Values can be: gain: Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power: Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade. string gain, power Table 1.8 Pitch Opcode Description Type Range transpose= The transposition value for this region which will be applied to the sample. integer -127 to 127 transpose_onccN= transpose_smoothccN= transpoe_curveccN= tune= The fine tuning for the sample, in cents. Range is \u00b11 semitone, from -100 to 100. Only negative values must be prefixed with sign. integer -100 to 100 cents tune_onccN= tune_smoothccN= tune_curveccN= pitch_keycenter= Root key for the sample. integer -127 to 127 pitch_keytrack= Within the region, this value defines how much the pitch changes with every note. Default value is 100, which means pitch will change one hundred cents (one semitone) per played note. Setting this value to zero means that all notes in the region will play the same pitch, particularly useful when mapping drum sounds. integer -1200 to 1200 cents pitch_veltrack= Pitch velocity tracking, represents how much the pitch changes with incoming note velocity, in cents. integer -9600 to 9600 cents pitch_random= Random tuning for the region, in cents. Random pitch will be centered, with positive and negative values. integer 0 to 9600 cents bend_up= Pitch bend range when Pitch Wheel or Joystick is moved up, in cents. integer -9600 to 9600 cents bend_down= Pitch bend range when Pitch Wheel or Joystick is moved down, in cents. integer -9600 to 9600 cents bend_step= Pitch bend step, in cents. integer 1 to 1200 cents Table 1.9 Filter Two filters are available in SFZ version 2. To use the second filter, use opcode with the number 2. Opcode Description Type Range fil_type= fil2_type= Filter type. Avaliable types are: lpf_1p: one-pole low pass filter (6dB/octave). hpf_1p: one-pole high pass filter (6dB/octave). bpf_1p: one-pole band pass filter (6dB/octave). brf_1p: one-pole band rejection filter (6dB/octave). apf_1p: one-pole all pass filter (6dB/octave). lpf_2p: two-pole low pass filter (12dB/octave). hpf_2p: two-pole high pass filter (12dB/octave). bpf_2p: two-pole band pass filter (12dB/octave). brf_2p: two-pole band rejection filter (12dB/octave). pkf_2p: two-pole peak filter (12dB/octave). lpf_4p: four-pole low pass filter (24dB/octave). hpf_4p: four-pole high pass filter (24dB/octave). lpf_6p: six-pole low pas filter (36dB/octave). hpf_6p: six-pole high pass filter (36dB/octave). comb: comb filter pink: pink filter string lpf_1p, hpf_1p, bpf_1p, brf_1p, apf_1p, lpf_2p, hpf_2p, bpf_2p, brf_2p, pkf_2p, lpf_4p, hpf_4p, lpf_6p, hpf_6p, comb, pink cutoff= cutoff2= The filter cutoff frequency, in Hz. If the cutoff is not specified, the filter will be disabled, with the consequent CPU drop in the player. float 0 to SR/2 cutoff_onccN= cutoff2_onccN= The variation in the cutoff frequency when MIDI continuous controller N is received, in cents. integer -9600 to 9600 cents cutoff_smoothccN= cutoff2_smoothccN= The smooth factor defines how smooth the change is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer -9600 to 9600 cents cutoff_stepccN= cutoff2_stepccN= The step factor sets in what steps that the variation is introduced. integer -9600 to 9600 cents cutoff_curveccN= cutoff2_curveccN= Select a curve defined internally or in a section. integer ? cutoff_chanaft= cutoff2_chanaft= The variation in the cutoff frequency when MIDI channel aftertouch messages are received, in cents. integer -9600 to 9600 cents cutoff_polyaft= cutoff2_polyaft= The variation in the cutoff frequency when MIDI polyphonic aftertouch messages are received, in cents. integer -9600 to 9600 cents resonance= resonance2= The filter cutoff resonance value, in dB. float 0 to 40 dB resonance_onccN= resonance2_onccN= The filter cutoff resonance value modulated by MIDI continuous controller N, in dB. float 0 to 40 dB resonance_smoothccN= resonance2_smoothccN= The smooth factor defines how smooth the modulation is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. float 0 to 40 dB resonance_stepccN= resonance2_stepccN= The step factor sets in what steps that the modulation is introduced. float 0 to 40 dB resonance_curveccN= resonance2_curveccN= Select a curve defined internally or in a section. integer 0 to 4294967296 fil_keytrack= fil2_keytrack= Filter keyboard tracking (change on cutoff for each key) in cents. integer 0 to 1200 cents fil_keycenter= fil2_keycenter= Center key for filter keyboard tracking. In this key, the filter keyboard tracking will have no effect. integer 0 to 127 fil_veltrack= fil2_veltrack= Filter velocity tracking, represents how much the cutoff changes with incoming note velocity. integer -9600 to 9600 cents fil_random= fil2_random= Random cutoff added to the region, in cents. integer 0 to 9600 cents Table 1.10 Envelope Generators The first seven EGs might already be in use by the player. To be compatible across different players start with EG number 8. Opcode Description Type Range egN_timeX= Set the time of the node X in the envelope generator N to the specified value. float 0 to 100 seconds egN_timeX_onccY= Set the time of the node X in the envelope generator N to the specified value modulated by MIDI continuous controller X. float 0 to 100 seconds egN_levelX= Sets the level of the node X in the envelope generator N to the specified value. float 0 to 1 egN_levelX_onccY= Sets the level of the node X in the envelope generator N to the specified value modulated by MIDI continuous controller X. float 0 to 1 egN_shapeX= Sets the shape of the segment X in the flexible envelope generator N to one of the predefined shapes. float 0 to 1 egN_curveX= Defines the curve of the segment X in the envelope generator N. float 0 to 1 egN_sustain= Sets the specified node as the sustain node for the envelope generator N. integer 0 to 100 egN_loop= Sets the specified node as the loop node for the envelope generator N. integer 0 to 100 egN_loop_count= Defines the number of repeats for the loop in the envelope generator N. integer 0 to 4294967296 egN_volume= Patch envelope generator N to the amplifier. The EGs normalized output will be multiplied by the opcode value and added to the destination. float -144 to 6 dB egN_amplitude= -\"- float 0 to 100 % egN_pan= egN_width= egN_position= -\"- float -100 to 100 % egN_pan_curve= egN_pan_curveccX= Select a curve defined internally or in a section. integer ? egN_volume_onccX= Patch envelope generator N to the amplifier. The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. float -144 to 6 dB egN_amplitude_onccX= -\"- float 0 to 100 % egN_pan_onccX= egN_width_onccX= egN_position_onccX= -\"- float -100 to 100% egN_freq_lfoX= Patch envelope generator N to LFO X. The EGs normalized output will be multiplied by the opcode value and added to the destination. float 0 to 20 Hz egN_depth_lfoX= egN_depthadd_lfoX= -\"- integer -1200 to 1200 cents egN_pitch= Patch envelope generator N to the pitch. The EGs normalized output will be multiplied by the opcode value and added to the destination. integer -9600 to 9600 cents egN_pitch_onccX= Patch envelope generator N to the pitch. The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. integer -9600 to 9600 cents egN_cutoff= egN_cutoff2= Patch envelope generator N to the filter. The EGs normalized output will be multiplied by the opcode value and added to the destination. integer -9600 to 9600 cents egN_resonance= egN_resonance2= -\"- float 0 to 40dB egN_cutoff_onccX= egN_cutoff2_onccX= Patch envelope generator N to the filter. The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. integer -9600 to 9600 cents egN_resonance_onccX= egN_resonance2_onccX= -\"- float 0 to 40 dB egN_eq1freq= egN_eq2freq= egN_eq3freq= Patch envelope generator N to the per voice equalizer. The EGs normalized output will be multiplied by the opcode value and added to the destination. float 0 to 30000 Hz egN_eq1bw= egN_eq2bw= egN_eq3bw= -\"- float 0.001 to 4 octaves egN_eq1gain= egN_eq2gain= egN_eq3gain= -\"- float -96 to 24 dB egN_eq1freq_onccX= egN_eq2freq_onccX= egN_eq3freq_onccX= Patch envelope generator N to the per voice equalizer. The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. float 0 to 30000 Hz egN_eq1bw_onccX= egN_eq2bw_onccX= egN_eq3bw_onccX= -\"- float 0.001 to 4 octaves egN_eq1gain_onccX= egN_eq2gain_onccX= egN_eq3gain_onccX= -\"- float -96 to 24 dB egN_decim= egN_bitred= egN_rectify= egN_ringmod= egN_noiselevel= egN_noisestep= egN_noisetone= egN_driveshape= Patch envelope generator N to effects. The EGs normalized output will be multiplied by the opcode value and added to the destination. ? ? egN_decim_onccX= egN_bitred_onccX= egN_rectify_onccX= egN_ringmod_onccX= egN_noiselevel_onccX= egN_noisestep_onccX= egN_noisetone_onccX= egN_driveshape_onccX= The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X ? ? Table 1.11 Low-Frequency Oscillators The first seven LFOs might already be in use by the player. To be compatible across different players start with LFO number 8. Opcode Description Type Range lfoN_freq= Defines the frequency for the LFO N, in Hz. float 0 to 20 Hz lfoN_freq_onccX= Defines the frequency variation modulated by MIDI continuous controller X for the LFO N, in Hz. float 0 to 20 Hz lfoN_freq_smoothccX= The smooth factor defines how smooth MIDI continuous controller X modulation is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_freq_stepccX= The step factor sets in what steps that variation is introduced. float 0 to 20 Hz lfoN_delay= Sets a delay time from the region instantiation to the LFO N starts working, in seconds. float 0 to 100 seconds lfoN_delay_onccX= Sets a delay time from the region instantiation to the LFO N starts working modulated by MIDI continuous controller X, in seconds. float 0 to 100 seconds lfoN_fade= Defines a fade-in ramp from region instantiation for the LFO N output, in seconds. float 0 to 100 seconds lfoN_fade_onccX= Defines a fade-in ramp from the region instantiation for the LFO N output modulated by MIDI continuous controller X, in seconds. float 0 to 100 seconds lfoN_depth= lfoN_depth_onccN= lfoN_phase= Sets the initial phase of the LFO N. float 0 to 360 degrees lfoN_phase_onccX= Sets the initial phase of LFO N modulated by MIDI continuous controller X. float 0 to 360 degrees lfoN_count= Defines a cycle count for the LFO N. After that cycle count, the LFO will stop. Default is infinite. integer 0 to 4294967296 lfoN_wave= Set the waveform for LFO N. The wave pool is player dependant, but the following waveforms are mandatory: 0: triangle 1: sine 2: pulse 75% 3: square (pulse 50%) 4: pulse 25% 5: pulse 12.5% 6: saw up 7: saw down integer 0 to 4294967296 lfoN_steps= Turns the LFO N into a step sequencer, with a number of steps specified in the value. integer 0 to 4294967296 lfoN_stepX= Defines the level of step X in the LFO N. float 0 to 1 lfoN_smooth= Sets the smoothing for the LFO N output. ? ? lfoN_smooth_onccX= Sets the smoothing for the LFO N output modulated by MIDI continuous controller X. ? ? lfoN_volume= Patch LFO N to amplifier. The LFOs normalized output will be multiplied by the opcode value and added to the destination. float -144 to 6 dB lfoN_amplitude= -\"- float 0 to 100 % lfoN_pan= lfoN_width= lfoN_position= -\"- float -100 to 100 % lfoN_volume_onccX= Patch LFO N to amplifier. The LFOs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. float -144 to 6 dB lfoN_amplitude_onccX= -\"- float 0 to 100 % lfoN_pan_onccX= lfoN_width_onccX= lfoN_position_onccX= -\"- float -100 to 100 % lfoN_volume_smoothccX= lfoN_amplitude_smoothccX= lfoN_pan_smoothccX= lfoN_width_smoothccX= lfoN_position_smoothccX= The smooth factor defines how smooth the modulation is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_volume_stepccX= lfoN_amplitude_stepccX= lfoN_pan_stepccX= lfoN_width_stepccX= lfoN_position_stepccX= The step factor sets in what steps that modulation is introduced. integer 0 to 4294967296 lfoN_freq_lfoX= Patch LFO N to LFO X. The LFOs normalized output will be multiplied by the opcode value and added to the destination. float 0 to 20 Hz lfoN_depth_lfoX= lfoN_depthadd_lfoX= -\"- integer -1200 to 1200 cents lfoN_pitch= Patch LFO N to the pitch. The LFOs normalized output will be multiplied by the opcode value and added to the destination. integer -9600 to 9600 cents lfoN_pitch_onccX= Pitch of LFO N modulated by MIDI continuous controller X. ? ? lfoN_pitch_smoothccX= Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer lfoN_pitch_stepccX= The step factor sets in what steps that variation is introduced. integer 0 to 4294967296 lfoN_cutoff= lfoN_cutoff2= Patch LFO N to the filter. The LFOs normalized output will be multiplied by the opcode value and added to the destination. integer -9600 to 9600 cents lfoN_resonance= lfoN_resonance2= -\"- float 0 to 40 dB lfoN_cutoff_onccX= lfoN_cutoff2_onccX= Patch LFO N to the filter. The LFOs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. integer -9600 to 9600 cents lfoN_resonance_onccX= lfoN_resonance2_onccX= -\"- float 0 to 40 dB lfoN_cutoff_smoothccX= lfoN_cutoff2_smoothccX= lfoN_resonance_smoothccX= lfoN_resonance2_smoothX= The smooth factor defines how smooth the change is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_cutoff_stepccX= lfoN_cutoff2_stepccX= lfoN_resonance_stepccX= lfoN_resonance2_stepccX= The step factor sets in what steps that variation is introduced. integer 0 to 4294967296 lfoN_eq1freq= lfoN_eq2freq= lfoN_eq3freq= Patch LFO N to the per voice equalizer. The LFOs normalized output will be multiplied by the opcode value and added to the destination. float 0 to 30000 Hz lfoN_eq1bw= lfoN_eq2bw= lfoN_eq3bw= -\"- float 0.001 to 4 octaves lfoN_eq1gain= lfoN_eq2gain= lfoN_eq3gain= -\"- float -96 to 24 dB lfoN_eq1freq_onccX= lfoN_eq2freq_onccX= lfoN_eq3freq_onccX= Patch LFO N to the per voice equalizer. The LFOs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. float 0 to 30000 Hz lfoN_eq1bw_onccX= lfoN_eq2bw_onccX= lfoN_eq3bw_onccX= -\"- float 0.001 to 4 octaves lfoN_eq1gain_onccX= lfoN_eq2gain_onccX= lfoN_eq3gain_onccX= -\"- float -96 to 24 dB lfoN_eq1freq_smoothccX= lfoN_eq2freq_smoothccX= lfoN_eq3freq_smoothccX= lfoN_eq1bw_smoothccX= lfoN_eq2bw_smoothccX= lfoN_eq3bw_smoothccX= lfoN_eq1gain_smoothccX= lfoN_eq2gain_smoothccX= lfoN_eq3gain_smoothccX= The smooth factor defines how smooth the change is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_eq1freq_stepccX= lfoN_eq2freq_stepccX= lfoN_eq3freq_stepccX= lfoN_eq1bw_stepccX= lfoN_eq2bw_stepccX= lfoN_eq3bw_stepccX= lfoN_eq1gain_stepccX= lfoN_eq2gain_stepccX= lfoN_eq3gain_stepccX= The step factor sets in what steps that variation is introduced. integer 0 to 4294967296 lfoN_decim= lfoN_bitred= lfoN_noiselevel= lfoN_noisestep= lfoN_noisetone= lfoN_drive= Patch LFO N to effects. ? ? lfoN_decim_onccX= lfoN_bitred_onccX= lfoN_noiselevel_onccX= lfoN_noisestep_onccX= lfoN_noisetone_onccX= lfoN_drive_onccX= Modulated by MIDI continuous control N. ? ? lfoN_decim_smoothccX= lfoN_bitred_smoothccX= lfoN_noiselevel_smoothccX= lfoN_noisestep_smoothccX= lfoN_noisetone_smoothccX= lfoN_drive_smoothccX= The smooth factor defines how smooth the change is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_decim_stepccX= lfoN_bitred_stepccX= lfoN_noiselevel_stepccX= lfoN_noisestep_stepccX= lfoN_noisetone_stepccX= lfoN_drive_stepccX= The step factor sets in what steps that variation is introduced. ? ? Table 1.12 Equalizer Note that the equalizers are monophonic (i.e. they apply to all notes playing) while these are polyphonic (i.e. they apply per voice). Opcode Description Type Range eq1_freq= eq2_freq= eq3_freq= Frequency of the equalizer band, in Hz. float 0 to 30000 Hz eq1_freq_onccN= eq2_freq_onccN= eq3_freq_onccN= Frequency change of the equalizer band modulated by MIDI continuous control N, in Hz. float -30000 to 30000 Hz eq1_vel2freq= eq2_vel2freq= eq3_vel2freq= Frequency change of the equalizer band with MIDI velocity, in Hz. float -30000 to 30000 Hz eq1_bw= eq2_bw= eq3_bw= Bandwidth of the equalizer band, in octaves. float 0.001 to 4 octaves eq1_bw_onccN= eq2_bw_onccN= eq3_bw_onccN= Bandwidth change of the equalizer band modulated by MIDI continuous control N, in octaves. float -4 to 4 octaves eq1_gain= eq2_gain= eq3_gain= Gain of the equalizer band, in dB. float -96 to 24 dB eq1_gain_onccN= eq2_gain_onccN= eq3_gain_onccN= Gain change of the equalizer band modulated by MIDI continuous control N, in dB. float -96 to 24 dB eq1_vel2gain= eq2_vel2gain= eq3_vel2gain= Gain change of the equalizer band with MIDI velocity, in dB. float -96 to 24 dB Table 1.13 Effects (SFZ v2) All effects should be prefaced with the header. Opcode Description Type Range Table 1.14 Effects (SFZ v1) Opcode Description Type Range effect1= Level of effect1 send (reverb). float 0 to 100 % effect2= Level of effect2 send (chorus). float 0 to 100 % Table 1.15 Amplifier EG (SFZ v1) These have been deprecated. Use the much more flexible EGs in Table 1.10 instead. Opcode Description Type Range ampeg_delay= Amplifier EG delay time, in seconds. This is the time elapsed from note on to the start of the Attack stage. float 0 to 100 seconds ampeg_start= Amplifier EG start level, in percentage. float 0 to 100 % ampeg_attack= Amplifier EG attack time, in seconds. float 0 to 100 seconds ampeg_hold= Amplifier EG hold time, in seconds. During the hold stage, EG output will remain at its maximum value. float 0 to 100 seconds ampeg_decay= Amplifier EG decay time, in seconds. float 0 to 100 seconds ampeg_sustain= Amplifier EG sustain level, in percentage. float 0 to 100 % ampeg_release= Amplifier EG release time (after note release), in seconds. float 0 to 100 seconds ampeg_vel2delay= Velocity effect on amplifier EG delay time, in seconds. float -100 to 100 seconds ampeg_vel2attack= Velocity effect on amplifier EG attack time, in seconds. float -100 to 100 seconds ampeg_vel2hold= Velocity effect on amplifier EG hold time, in seconds. float -100 to 100 seconds ampeg_vel2decay= Velocity effect on amplifier EG decay time, in seconds float -100 to 100 seconds ampeg_vel2sustain= Velocity effect on amplifier EG sustain level, in percentage. float -100 to 100 % ampeg_vel2release= Velocity effect on amplifier EG release time, in seconds. float -100 to 100 seconds ampeg_delay_onccN= Amplifier EG delay time added on MIDI control N, in seconds. float -100 to 100 seconds ampeg_start_onccN= Amplifier EG start level added on MIDI control N, in percentage. float -100 to 100 % ampeg_attack_onccN= Amplifier EG attack time added on MIDI control N, in seconds. float -100 to 100 second ampeg_hold_onccN= Amplifier EG hold time added on MIDI control N, in seconds. float -100 to 100 seconds ampeg_decay_onccN= Amplifier EG decay time added on MIDI control N, in seconds. float -100 to 100 seconds ampeg_sustain_onccN= Amplifier EG sustain level added on MIDI control N, in percentage. float -100 to 100 % ampeg_release_onccN= Amplifier EG release time added on MIDI control N, in seconds. float -100 to 100 seconds Table 1.16 Amplifier LFO (SFZ v1) These have been deprecated. Use the much more flexible LFOs in Table 1.11 instead. Opcode Description Type Range amplfo_delay= The time before the Amplifier LFO starts oscillating, in seconds. float 0 to 100 seconds amplfo_delay_onccN= The time before the Amplifier LFO starts oscillating modulated by MIDI continuous controller N, in seconds. float 0 to 100 seconds amplfo_fade= Amplifier LFO fade-in effect time, in seconds. float 0 to 100 seconds amplfo_fade_onccN= Amplifier LFO fade-in effect time modulated by MIDI continuous controller N, in seconds. float 0 to 100 seconds amplfo_freq= Amplifier LFO frequency, in hertz. float 0 to 20 hertz amplfo_freq_onccN= Amplifier LFO frequency change when MIDI continuous controller N is received, in hertz. float -200 to 200 hertz amplfo_freqchanaft= Amplifier LFO frequency change when channel aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz amplfo_freqpolyaft= Amplifier LFO frequency change when polyphonic aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz amplfo_depth= Amplifier LFO depth, in decibels. float -10 to 10 dB amplfo_depth_onccN= Amplifier LFO depth when MIDI continuous controller N is received, in decibels. float -10 to 10 dB amplfo_depthchanaft= Amplifier LFO depth when polyphonic aftertouch MIDI messages are received, in cents. float -10 to 10 dB amplfo_depthpolyaft= Amplifier LFO frequency change when polyphonic aftertouch MIDI messages are received, in hertz. float -10 to 10 dB Table 1.17 Filter EG (SFZ v1) These have been deprecated. Use the much more flexible EGs in Table 1.10 instead. Opcode Description Type Range fileg_delay= Filter EG delay time, in seconds. This is the time elapsed from note on to the start of the Attack stage. float 0 to 100 seconds fileg_start= Filter EG start level, in percentage. float 0 to 100 % fileg_attack= Filter EG attack time, in seconds. float 0 to 100 seconds fileg_hold= Filter EG hold time, in seconds. During the hold stage, EG output will remain at its maximum value. float 0 to 100 seconds fileg_decay= Filter EG decay time, in seconds. float 0 to 100 seconds fileg_sustain= Filter EG sustain level, in percentage. float 0 to 100 % fileg_release= Filter EG release time (after note release), in seconds. float 0 to 100 seconds fileg_depth= Depth or the filter EG, in cents. integer -12000 to 12000 cents fileg_vel2delay= Velocity effect on filter EG delay time, in seconds. float -100 to 100 seconds fileg_vel2attack= Velocity effect on filter EG attack time, in seconds. float -100 to 100 seconds fileg_vel2hold= Velocity effect on filter EG hold time, in seconds. float -100 to 100 seconds fileg_vel2decay= Velocity effect on filter EG decay time, in seconds. float -100 to 100 seconds fileg_vel2sustain= Velocity effect on filter EG sustain level, in percentage. float -100 to 100 % fileg_vel2release= Velocity effect on filter EG release time, in seconds. float -100 to 100 seconds fileg_vel2depth= integer -12000 to 12000 cents fileg_delay_onccN= float -100 to 100 seconds fileg_start_onccN= float -100 to 100 seconds fileg_attack_onccN= float -100 to 100 seconds fileg_hold_onccN= float -100 to 100 seconds fileg_decay_onccN= float -100 to 100 seconds fileg_sustain_onccN= float -100 to 100 % fileg_release_onccN= float -100 to 100 seconds fileg_depth_onccN= integer -12000 to 12000 cents Table 1.18 Filter LFO (SFZ v1) These have been deprecated. Use the much more flexible LFOs in Table 1.11 instead. Opcode Description Type Range fillfo_delay= The time before the filter LFO starts oscillating, in seconds. float 0 to 100 seconds fillfo_delay_onccN= float -100 to 100 seconds fillfo_fade= Filter LFO fade-in effect time. float 0 to 100 seconds fillfo_fade_onccN= float -100 to 100 seconds fillfo_freq= Filter LFO frequency, in hertz. float 0 to 20 hertz fillfo_freq_onccN= Filter LFO frequency change when MIDI continuous controller N is received, in hertz. float -200 to 200 hertz fillfo_freqchanaft= Filter LFO frequency change when channel aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz fillfo_freqpolyaft= Filter LFO frequency change when polyphonic aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz fillfo_depth= Filter LFO depth, in cents. integer -1200 to 1200 cents fillfo_depth_onccN= Filter LFO depth when MIDI continuous controller N is received, in cents. integer -1200 to 1200 cents fillfo_depthchanaft= Filter LFO depth when channel aftertouch MIDI messages are received, in cents. integer -1200 to 1200 cents fillfo_depthpolyaft= Filter LFO depth when polyphonic aftertouch MIDI messages are received, in cents. integer -1200 to 1200 cents Table 1.19 Pitch EG (SFZ v1) These have been deprecated. Use the much more flexible EGs in Table 1.10 instead. Opcode Description Type Range pitcheg_delay= Pitch EG delay time, in seconds. This is the time elapsed from note on to the start of the Attack stage. float 0 to 100 seconds pitcheg_start= Pitch EG start level, in percentage. float 0 to 100 % pitcheg_attack= Pitch EG attack time, in seconds. float 0 to 100 seconds pitcheg_hold= Pitch EG hold time, in seconds. During the hold stage, EG output will remain at its maximum value. float 0 to 100 seconds pitcheg_decay= Pitch EG decay time, in seconds. float 0 to 100 seconds pitcheg_sustain= Pitch EG release time (after note release), in seconds. float 0 to 100 % pitcheg_release= Pitch EG release time (after note release), in seconds. float 0 to 100 seconds pitcheg_depth= Depth for the pitch EG, in cents. integer -12000 to 12000 cents pitcheg_vel2delay= Velocity effect on pitch EG delay time, in seconds. float -100 to 100 seconds pitcheg_vel2attack= Velocity effect on pitch EG attack time, in seconds. float -100 to 100 seconds pitcheg_vel2hold= Velocity effect on pitch EG hold time, in seconds. float -100 to 100 seconds pitcheg_vel2decay= Velocity effect on pitch EG decay time, in seconds. float -100 to 100 seconds pitcheg_vel2sustain= Velocity effect on pitch EG sustain level, in percentage. float -100 to 100 % pitcheg_vel2release= Velocity effect on pitch EG release time, in seconds. float -100 to 100 seconds pitcheg_vel2depth= Velocity effect on pitch EG depth, in cents. integer -12000 to 12000 cents pitcheg_delay_onccN= float -100 to 100 seconds pitcheg_start_onccN= float -100 to 100 seconds pitcheg_attack_onccN= float -100 to 100 seconds pitcheg_hold_onccN= float -100 to 100 seconds pitcheg_decay_onccN= float -100 to 100 seconds pitcheg_sustain_onccN= float -100 to 100 % pitcheg_release_onccN= float -100 to 100 seconds pitcheg_depth_onccN= integer -12000 to 12000 cents Table 1.20 Pitch LFO (SFZ v1) These have been deprecated. Use the much more flexible LFOs in Table 1.11 instead. Opcode Description Type Range pitchlfo_delay= The time before the Pitch LFO starts oscillating, in seconds. float 0 to 100 seconds pitchlfo_delay_onccN= float -100 to 100 seconds pitchlfo_fade= Pitch LFO fade-in effect time. float 0 to 100 seconds pitchlfo_fade_onccN= float -100 to 100 seconds pitchlfo_freq= Pitch LFO frequency, in hertz. float 0 to 20 hertz pitchlfo_freq_onccN= Pitch LFO frequency change when MIDI continuous controller N is received, in hertz. float -200 to 200 hertz pitchlfo_freqchanaft= Pitch LFO frequency change when channel aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz pitchlfo_freqpolyaft= Pitch LFO frequency change when polyphonic aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz pitchlfo_depth= Pitch LFO depth, in cents. integer -1200 to 1200 cents pitchlfo_depth_onccN= Pitch LFO depth when MIDI continuous controller N is received, in cents. integer -1200 to 1200 cents pitchlfo_depthchanaft= Pitch LFO depth when channel aftertouch MIDI messages are received, in cents. integer -1200 to 1200 cents pitchlfo_depthpolyaft= Pitch LFO depth when polyphonic aftertouch MIDI messages are received, in cents. integer -1200 to 1200 cents Table 1.21 Curve The first six curves are predefined by the player and usually player specific if implemented, custom curve number 7 and up can be defined using the <curve> header. Opcode Description Type Range vN= Define normalized values on curve. float 0 to 1 Table 1.22 Global There can be one <global> header in a file. Their settings are global for the whole file. The following opcodes can only be defined in the global header. Opcode Description Type Range polyphony= Limits the polyphony to number of voices. The default is infinite or maximal number of voices the player can handle, whichever comes first. integer n/a sustain_sw= Enable/disable the sustain pedal. string on, off","title":"LinuxSampler SFZ Reference"},{"location":"en/linuxsampler/sfz/#table-of-contents","text":"LinuxSampler SFZ Implementation Introduction Structure Region Group Global Control Curve Effects Comments Units MIDI Continuous Controller Modulation Additional Controllers Table 1.1 Sample Definition Table 1.2 Control Table 1.3 Loading Table 1.4 Wavetable Oscillator Table 1.5 Input Controls Table 1.6 Sample Player Table 1.7 Amplifier Table 1.8 Pitch Table 1.9 Filter Table 1.10 Envelope Generators Table 1.11 Low-Frequency Oscillators Table 1.12 Equalizer Table 1.13 Effects (SFZ v2) Table 1.14 Effects (SFZ v1) Table 1.15 Amplifier EG (SFZ v1) Table 1.16 Amplifier LFO (SFZ v1) Table 1.17 Filter EG (SFZ v1) Table 1.18 Filter LFO (SFZ v1) Table 1.19 Pitch EG (SFZ v1) Table 1.20 Pitch LFO (SFZ v1) Table 1.21 Curve Table 1.22 Global This is a work in progress!","title":"Table of Contents"},{"location":"en/linuxsampler/sfz/#introduction","text":"SFZ is a file format to define how a collection of samples and other type of oscillators are arranged for performance. The goal behind the SFZ format is to provide a free, simple, minimalistic and expandable format to arrange, distribute and use audio samples with the highest possible quality and the highest possible performance flexibility. Soundware, software and hardware developers can create, use and distribute the SFZ format files for free, for either free or commercial applications. The following is an overview of the implementation of SFZ in LinuxSampler. It will serve as a chart of the state of our implementation. The numbering of tables (up to 1.20) correspond to Cakewalk Synthesizers Appendix A . Some opcodes introduced by Garritan/Plogue in their ARIA engine have been included. Missing and otherwise omitted opcodes have also been added to the tables by us. This document represents LinuxSamplers interpretation of the SFZ format and is not guaranteed to be correct in any way, shape or form. ~~Stricken~~ opcodes in tables are not implemented by LinuxSampler at this time. All opcodes are in lower case, capitalized N , X and Y in opcode names indicate an integer number.","title":"Introduction"},{"location":"en/linuxsampler/sfz/#structure","text":"An instrument in the SFZ format is a collection of sample files and a SFZ definition file. A SFZ definition file contain two types of tokens: headers and opcodes . Headers starts with a lesser-than character (<) and ends with a greater-than character (>). Opcodes are key/value pairs separated by an equal to sign (=). The opcode values can either be integers, floating point numbers or strings.","title":"Structure"},{"location":"en/linuxsampler/sfz/#region","text":"An instrument is defined as a collection of regions. A region include the definition for the input controls (when and how the region will be triggered for playback), the samples to be played and the performance parameters (how to play those samples). A region starts with the <region> header and is followed by one or more opcodes.","title":"Region"},{"location":"en/linuxsampler/sfz/#group","text":"Regions can be arranged into groups. Groups allow entering common parameters for multiple regions, think of it as a template for regions. A group start with the <group> header and is followed by one or more opcodes.","title":"Group"},{"location":"en/linuxsampler/sfz/#global","text":"Global settings applying to the whole SFZ definition file can be defined. Think of it as a template for all groups and regions. Some opcodes can only be set here. The global settings start with the <global> header and is followed by one or more opcodes (see Table 1.22 ).","title":"Global"},{"location":"en/linuxsampler/sfz/#control","text":"Control directives are used to specify a default path to the location of samples or set the default position for any MIDI continuous controller. Those are special opcodes that can only be set here. The control settings start with the <control> header and is followed by one or more opcodes (see Table 1.2 ).","title":"Control"},{"location":"en/linuxsampler/sfz/#curve","text":"The player define up to six curves internally but additional custom curves can also be defined. A custom curve start with the <curve> header and is followed by one or more curve value opcodes (see Table 1.21 ).","title":"Curve"},{"location":"en/linuxsampler/sfz/#effects","text":"Effects that should apply to all voices can be defined. Effects start with the <effects> header and is followed by one or more effect opcodes (see Table 1.13 ).","title":"Effects"},{"location":"en/linuxsampler/sfz/#comments","text":"Comment lines can be inserted anywhere inside the file. A comment line starts with two slash characters ('//') and it extends until the end of the line.","title":"Comments"},{"location":"en/linuxsampler/sfz/#units","text":"All units in the SFZ format are in real-world values. Frequencies are expressed in Hertz , pitches in cents , amplitudes in percentage and volumes in decibels . Notes are expressed in MIDI Note Numbers, or in note names according to the International Pitch Notation (IPN) convention. According to this rules, middle C in the keyboard is C4 and the MIDI note number 60.","title":"Units"},{"location":"en/linuxsampler/sfz/#midi-continuous-controller","text":"","title":"MIDI Continuous Controller"},{"location":"en/linuxsampler/sfz/#modulation","text":"Everything that can be modulated by a continuous controller has a _oncc opcode suffix. A _smoothcc suffix sets the speed of parameter change in milliseconds. A _stepcc sets in what steps the parameter change is introduced. A _curvecc suffix sets the curve defined in the file.","title":"Modulation"},{"location":"en/linuxsampler/sfz/#additional-controllers","text":"SFZ support an extended set of MIDI CC messages generated by the various Cakewalk synthesizers GUIs. Events for the following CC numbers are generated by other MIDI events or internal generators and therefore might be applicable to our implementation: 128: bend 129: channel aftertouch 130: polyphonic aftertouch 131: velocity 132: release velocity 133: keyboard (noye 0=0, note 127=1) 134: key gate (0 if no keys are pressed, 1 otherwise) 135: random (0 to 1) 136: random (-1 to 1) 137: alternate (changes from 0 to 1 and vice versa)","title":"Additional Controllers"},{"location":"en/linuxsampler/sfz/#table-11-sample-definition","text":"| Opcode | Description | Type | Range | ---------------- | ----------- | ---- | | sample= | This opcode defines which sample file the region will play. The value of this opcode is the filename of the sample file, including the extension. The filename must be stored in the same folder where the definition file is, or specified relatively to it. If the sample file is not found, the player will ignore the whole region contents. Long names and names with blank spaces and other special characters (excepting the = character) are allowed in the sample definition. The sample file can either be a WAVE, AIFF or OGG file. | string | n/a | | ~~ md5= ~~ | ~~Verifies the MD5 hash of a sample on loading.~~ | ~~string~~ | ~~n/a~~ | ~~ waveguide= ~~ | ~~Instructs the player to treat the loaded sample as an impulse which is directed to a waveguide.~~ | ~~string~~ | ~~on off~~","title":"Table 1.1 Sample Definition"},{"location":"en/linuxsampler/sfz/#table-12-control","text":"There can be multiple <control> headers in a file. Their effects lasts until the end of the file or the next <control> header. Opcode Description Type Range default_path= This defines a default path, which will be added to every path in the sample opcode. string n/a octave_offset= This opcode sets an offset which will be applied to all note names and numbers in a definition. integer n/a note_offset= Shifts all notes in a given map. integer n/a set_ccN= Sets the named MIDI CC initial value. integer 0 to 127 ~~ #define ~~ ~~Allows for macro/text pre-processing~~ ~~string~~ ~~n/a~~","title":"Table 1.2 Control"},{"location":"en/linuxsampler/sfz/#table-13-loading","text":"Opcode Description Type Range ~~ load_mode= ~~ ~~Similar to \"load mode\" in Dimension Pro, but on a per-region basis. 0 : load as 32-bit 1 : load as 16-bit~~ ~~integer~~ ~~0 to 1~~ ~~ load_start= ~~ ~~ load_end= ~~ ~~Allows loading only part of a sample into memory.~~ ~~integer~~ ~~0 to 4294967296~~ ~~ sample_quality= ~~ ~~Sets the quality for sample-playback. 1 : linear 2 : high 3-10 : different sinc interpolated modes~~ ~~integer~~ ~~1 to 10~~ ~~ image= ~~ ~~Allows loading a BMP image, with or without alpha-channel for display purposes.~~ ~~string~~ ~~n/a~~","title":"Table 1.3 Loading"},{"location":"en/linuxsampler/sfz/#table-14-wavetable-oscillator","text":"Opcode Description Type Range ~~ oscillator= ~~ ~~If the value is set to on, the region becomes a wavetable oscillator. The sample specified in the region will be used to extract the spectral information and construct the wavetable.~~ ~~string~~ ~~on, off~~ ~~ oscillator_phase= ~~ ~~Sets the initial phase for the oscillator, from 0 to 360 degrees. A negative value will make the oscillator start at a random phase.~~ ~~integer~~ ~~-360 to 360 degrees~~ ~~ oscillator_quality= ~~ ~~Sets the quality for wavetable playback. 0 : nearest 1 : linear 2 : high 3 : dual-high~~ ~~integer~~ ~~0 to 3~~ ~~ oscillator_table_size= ~~ ~~Defines the table size of the wavetable used for the oscillator playback.~~ ~~integer~~ ~~0 to 4294967296~~ ~~ oscillator_multi= ~~ ~~Sets the oscillator to play in multi mode. When oscillator_mode=0 1 : engage a single oscillator 2 : engage ring modulation~~ ~~integer~~ ~~3 to 9~~ ~~ oscillator_mode= ~~ ~~Defines the playback mode for the oscillator. 0 : normal and ring modulation 1 : phase modulation 2 : frequency modulation~~ ~~integer~~ ~~0 to 2~~ ~~ oscillator_detune= ~~ ~~Sets the detune between the oscillators when in Multi, Ring, PM or FM modes.~~ ~~integer~~ ~~-100 to 100 cents~~ ~~ oscillator_detune_onccN= ~~ ~~Sets the detune between the oscillators modulated by MIDI continuous controller N.~~ ~~integer~~ ~~-100 to 100 cents~~ ~~ oscillator_mod_depth= ~~ ~~Sets the depth of modulation in PM/FM modes.~~ ~~integer~~ ~~-1200 to 1200 cents~~ ~~ oscillator_mod_depth_onccN= ~~ ~~Sets the depth of modulation in PM/FM modes modulated by MIDI continuous controller N.~~ ~~integer~~ ~~-1200 to 1200 cents~~ ~~ oscillator_mod_smoothcc= ~~ ~~Sets the control smooth for the depth of modulation when in PM/FM modes.~~","title":"Table 1.4 Wavetable Oscillator"},{"location":"en/linuxsampler/sfz/#table-15-input-controls","text":"The input controls define the conditions under which a region will get triggered and play back. Some input control states are defined at the instrument level while others (timer, sequence, key switches and groups) are defined at the region level. A region can be triggered by either a key or controller. The key and velocity will be used if triggered by a key. The controller number and value will be used if triggered by a controller. Opcode Description Type Range lochan= hichan= If incoming notes have a MIDI channel between lochan and hichan , the region will play. integer 1 to 16 lokey= hikey= key= If a note equal to or higher than lokey AND equal to or lower than hikey is played, the region will play. integer 0 to 127 lovel= hivel= If a note with velocity value equal to or higher than lovel AND equal to or lower than hivel is played, the region will play. integer 0 to 127 loccN= hiccN= Defines the range of the last MIDI controller N required for the region to play. integer 0 to 127 lobend= hibend= Defines the range of the last Pitch Bend message required for the region to play. integer -8192 to 8192 lobpm= hibpm= Host tempo value. The region will play if the host tempo is equal to or higher than lobpm , and lower than hibpm . integer 0 to 500 lochanaft= hichanaft= Defines the range of last Channel Aftertouch message required for the region to play. integer 0 to 127 lopolyaft= hipolyaft= Defines the range of last Polyphonic Aftertouch message required for the region to play. integer 0 to 127 loprog= hiprog= Sets a region playback based on the value of the last Program Change message recieved. integer 0 to 127 lorand= hirand= Random values. The player will generate a new random number on every note-on event, in the range 0~1. The region will play if the random number is equal to or higher than lorand , and lower than hirand . float 0 to 1 lotimer= hitimer= Set the region to play if the specified time has elapsed since a region in the same group has played. float n/a ~~ reverse_loccN= ~~ ~~ reverse_hiccN= ~~ ~~Sets the region into reverse playback based on a CC.~~ ~~integer~~ ~~0 to 127~~ seq_length= Sequence length. The player will keep an internal counter creating a consecutive note-on sequence for each region, starting at 1 and resetting at seq_length . integer 1 to 100 seq_position= Sequence position. The region will play if the internal sequence counter is equal to seq_position . integer 1 to 100 start_loccN= start_hiccN= stop_loccN= stop_hiccN= Defines a range of values to start a region playback, and another range of values of a control to stop the region playback (as replacements for note-on and note-off messages). integer 0 to 127 sw_lokey= sw_hikey= Defines the range of the keyboard to be used as trigger selectors for the sw_last opcode. integer 0 to 127 sw_last= Enables the region to play if the last key pressed in the range specified by sw_lokey and sw_hikey is equal to the sw_last value. integer 0 to 127 sw_down= Enables the region to play if the key equal to sw_down value is depressed. Key has to be in the range specified by sw_lokey and sw_hikey . integer 0 to 127 sw_up= Enables the region to play if the key equal to sw_up value is not depressed. Key has to be in the range specified by sw_lokey and sw_hikey . integer 0 to 127 sw_previous= Previous note value. The region will play if last note-on message was equal to sw_previous value. integer 0 to 127 sw_vel= This opcode allows overriding the velocity for the region with the velocity of the previous note. Values can be: current : Region uses the velocity of current note. previous : Region uses the velocity of the previous note. string current, previous trigger= Sets the trigger which will be used for the sample to play. Values can be: attack (default): Region will play on note-on. release : Region will play on note-off. The velocity used to play the note-off sample is the velocity value of the corresponding (previous) note-on message. first : Region will play on note-on, but if there's no other note going on (staccato, or first note in a legato phrase). legato : Region will play on note-on, but only if there's a note going on (notes after first note in a legato phrase). string attack, release, first, legato group= Exclusive group number for this region. integer 0 to 4294967296 off_by= Region off group. When a new region with a group number equal to off_by plays, this region will be turned off. integer 0 to 4294967296 off_mode= Region off mode. This opcode will determinate how a region is turned off by an off_by opcode. Values can be: fast (default): The voice will be turned off immediately. Release settings will not have any effect. normal : The region will be set into release stage. All envelope generators will enter in release stage, and region will expire when the amplifier envelope generator expired. string fast, normal on_loccN= on_hiccN= Sample trigger on MIDI continuous control N. If a MIDI control message with a value between on_loccN and on_hiccN is received, the region will play. integer 0 to 127","title":"Table 1.5 Input Controls"},{"location":"en/linuxsampler/sfz/#table-16-sample-player","text":"Opcode Description Type Range count= The number of times the sample will be played. If this opcode is specified, the sample will restart as many times as defined. Envelope generators will not be retriggered on sample restart. When this opcode is defined, loopmode is automatically set to one_shot . integer 0 to 4294967296 delay= Region delay time, in seconds. If a delay value is specified, the region playback will be postponed for the specified time. If the region receives a note-off message before delay time, the region won't play. All envelope generators delay stage will start counting after region delay time. float 0 to 100 seconds delay_onccN= Region delay time modulated by MIDI continuous controller N, in seconds. If the region receives a note-off message before delay time, the region won't play. All envelope generators delay stage will start counting after region delay time. float 0 to 100 seconds delay_random= Region random delay time, in seconds. If the region receives a note-off message before delay time, the region won't play. float 0 to 100 seconds delay_beats= stop_beats= Specify a region delay, or time-to-stop in beats, synchronized to host tempo. integer 0 to 32 beats delay_samples= delay_samples_onccN= Allows specifying a delay for a given region in samples (independent of sample rate). integer 0 to 4294967296 end= The endpoint of the sample, in sample units. The player will reproduce the whole sample if end is not specified. If end value is -1, the sample will not play. Marking a region end with -1 can be used to use a silent region to turn off other regions by using the group and off_by opcodes. integer -1 to 4294967296 loop_crossfade= Set a value for loop crossfading, in seconds. float 0 to 100 seconds offset= The offset used to play the sample, in sample units. The player will reproduce samples starting with the very first sample in the file, unless offset is specified. It will start playing the file at the offset sample in this case. integer 0 to 4294967296 offset_random= Random offset added to the region offset, in sample units. integer 0 to 4294967296 offset_onccN= The offset used to play the sample according to last position of MIDI continuous controller N, in sample units. integer 0 to 4294967296 loop_mode= If loop_mode is not specified, each sample will play according to its predefined loop mode. That is, the player will play the sample looped using the first defined loop, if available. If no loops are defined, the wave will play unlooped. The loop_mode opcode allows playing samples with loops defined in the unlooped mode. The possible values are: no_loop : no looping will be performed. Sample will play straight from start to end, or until note off, whatever reaches first. (Default for samples without a loop defined.) one_shot : sample will play from start to end, ignoring note off. This mode is engaged automatically if the count opcode is defined. loop_continuous : once the player reaches sample loop point, the loop will play until note expiration. loop_sustain : the player will play the loop while the note is held, by keeping it depressed or by using the sustain pedal (CC64). The rest of the sample will play after note release. (Default for samples with defined loop(s).) string no_loop, one_shot, loop_continuous, loop_sustain loop_start= The loop start point, in samples. If loop_start is not specified and the sample has a loop defined, the sample start point will be used. If loop_start is specified, it will overwrite the loop start point defined in the sample. This opcode will not have any effect if loopmode is set to no_loop . integer 0 to 4294967296 loop_end= The loop end point, in samples. This opcode will not have any effect if loopmode is set to no_loop . If loop_end is not specified and the sample have a loop defined, the sample loop end point will be used. If loop_end is specified, it will overwrite the loop end point defined in the sample. integer 0 to 4294967296 sync_beats= Region playing synchronization to host position. When sync_beats is specified and after input controls instruct the region to play, the playback will be postponed until the next multiple of the specified value is crossed. integer 0 to 32 beats sync_offset= Region playing synchronization to host position offset. When sync_beats is specified and after input controls instruct the region to play, the playback will be postponed until the next multiple of the specified value plus the sync_offset value is crossed. integer 0 to 32 beats","title":"Table 1.6 Sample Player"},{"location":"en/linuxsampler/sfz/#table-17-amplifier","text":"Opcode Description Type Range volume= The volume for the region, in dB. float -144 to 6 dB volume_onccN= volume_smoothccN= volume_curveccN= amplitude= The amplitude for the region, in percent. float 0 to 100 % amplitude_onccN= amplitude_smoothccN= amplitude_curveccN= pan= The panoramic position for the region, in percent. If a mono sample is used, pan value defines the position in the stereo image where the sample will be placed. When a stereo sample is used, the pan value the relative amplitude of one channel respect the other. A value of zero means centered, negative values move the panoramic to the left, positive to the right. float -100 to 100 % pan_onccN= pan_smoothccN= pan_curveccN= pan_law= string no_law width= Only operational for stereo samples, width defines the amount of channel mixing applied to play the sample. A width value of 0 makes a stereo sample play as if it were mono (adding both channels and compensating for the resulting volume change). A value of 100 will make the stereo sample play as original. Any value in between will mix left and right channels with a part of the other, resulting in a narrower stereo field image. Negative width values will reverse left and right channels. float -100 to 100 % width_onccN= width_smoothccN= width_curveccN= position= Only operational for stereo samples, positionwidth opcode. defines the position in the stereo field of a stereo signal, after channel mixing as defined in the A value of zero means centered, negative values move the panoramic to the left, positive to the right. float -100 to 100 % position_onccN= position_smoothccN= position_curveccN= amp_keytrack= Amplifier keyboard tracking (change in amplitude per key) in dB. float -96 to 12 dB amp_keycenter= Center key for amplifier keyboard tracking. In this key, the amplifier keyboard tracking will have no effect. integer 0 to 127 amp_veltrack= Amplifier velocity tracking, represents how much the amplitude changes with incoming note velocity. Volume changes with incoming velocity in a concave shape according to the following expression: Amplitude(dB) = 20 log (127^2 / Velocity^2) The amp_velcurve_N opcodes allow overriding the default velocity curve. float -100 to 100 % amp_velcurve_N= User-defined amplifier velocity curve. This opcode range allows defining a specific curve for the amplifier velocity. The value of the opcode indicates the normalized amplitude (0 to 1) for the specified velocity. float 0 to 1 amp_random= Random volume for the region, in dB. float 0 to 24 dB rt_decay= The volume decay amount when the region is set to play in release trigger mode, in decibels per second since note-on message. float 0 to 200 dB output= The stereo output number for this region. If the player doesn't feature multiple outputs, this opcode is ignored. n/a 0 to 1024 gain_onccN= Gain applied on MIDI control N, in dB. float -144 to 48 dB gain_smoothccN= gain_curveccN= xfin_lokey= xfin_hikey= Fade in control. xfin_lokey and xfin_hikey define the fade-in keyboard zone for the region. The volume of the region will be zero for keys lower than or equal to xfin_lokey, and maximum (as defined by the volume opcode) for keys greater than or equal to xfin_hikey. integer 0 to 127 xfout_lokey= xfout_hikey= Fade out control. xfout_lokey and xfout_hikey define the fade-out keyboard zone for the region. The volume of the region will be maximum (as defined by the volume opcode) for keys lower than or equal to xfout_lokey, and zero for keys greater than or equal to xfout_hikey. integer 0 to 127 xf_keycurve= Keyboard crossfade curve for the region. Values can be: gain: Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power: Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade. string gain, power xfin_lovel= xfin_hivel= Fade in control. xfin_lovel and xfin_hivel define the fade-in velocity range for the region. The volume of the region will be zero for velocities lower than or equal to xfin_lovel, and maximum (as defined by the volume opcode) for velocities greater than or equal to xfin_hivel. integer 0 to 127 xfout_lovel= xfout_hivel= Fade out control. xfout_lokey and xfout_hikey define the fade-out velocity range for the region. The volume of the region will be maximum (as defined by the volume opcode) for velocities lower than or equal to xfout_lovel, and zero for velocities greater than or equal to xfout_hivel. integer 0 to 127 xf_velcurve= Velocity crossfade curve for the region. Values can be: gain: Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power: Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade. string gain, power xfin_loccN= xfin_hiccN= Fade in control. xfin_loccN and xfin_hiccN set the range of values in the MIDI continuous controller N which will perform a fade-in in the region. The volume of the region will be zero for values of the MIDI continuous controller N lower than or equal to xfin_loccN, and maximum (as defined by the volume opcode) for values greater than or equal to xfin_hiccN. integer 0 to 127 xfout_loccN= xfout_hiccN= Fade out control. xfout_loccN and xfout_hiccN set the range of values in the MIDI continuous controller N which will perform a fade-out in the region. The volume of the region will be maximum (as defined by the volume opcode) for values of the MIDI continuous controller N lower than or equal to xfout_loccN, and zero for values greater than or equal to xfout_hiccN. integer 0 to 127 xf_cccurve= MIDI controllers crossfade curve for the region. Values can be: gain: Linear gain crossfade. This setting is best when crossfading phase-aligned material. Linear gain crossfades keep constant amplitude during the crossfade, preventing clipping. power: Equal-power RMS crossfade. This setting works better to mix very different material, as a constant power level is kept during the crossfade. string gain, power Table 1.8 Pitch Opcode Description Type Range transpose= The transposition value for this region which will be applied to the sample. integer -127 to 127 transpose_onccN= transpose_smoothccN= transpoe_curveccN= tune= The fine tuning for the sample, in cents. Range is \u00b11 semitone, from -100 to 100. Only negative values must be prefixed with sign. integer -100 to 100 cents tune_onccN= tune_smoothccN= tune_curveccN= pitch_keycenter= Root key for the sample. integer -127 to 127 pitch_keytrack= Within the region, this value defines how much the pitch changes with every note. Default value is 100, which means pitch will change one hundred cents (one semitone) per played note. Setting this value to zero means that all notes in the region will play the same pitch, particularly useful when mapping drum sounds. integer -1200 to 1200 cents pitch_veltrack= Pitch velocity tracking, represents how much the pitch changes with incoming note velocity, in cents. integer -9600 to 9600 cents pitch_random= Random tuning for the region, in cents. Random pitch will be centered, with positive and negative values. integer 0 to 9600 cents bend_up= Pitch bend range when Pitch Wheel or Joystick is moved up, in cents. integer -9600 to 9600 cents bend_down= Pitch bend range when Pitch Wheel or Joystick is moved down, in cents. integer -9600 to 9600 cents bend_step= Pitch bend step, in cents. integer 1 to 1200 cents Table 1.9 Filter Two filters are available in SFZ version 2. To use the second filter, use opcode with the number 2. Opcode Description Type Range fil_type= fil2_type= Filter type. Avaliable types are: lpf_1p: one-pole low pass filter (6dB/octave). hpf_1p: one-pole high pass filter (6dB/octave). bpf_1p: one-pole band pass filter (6dB/octave). brf_1p: one-pole band rejection filter (6dB/octave). apf_1p: one-pole all pass filter (6dB/octave). lpf_2p: two-pole low pass filter (12dB/octave). hpf_2p: two-pole high pass filter (12dB/octave). bpf_2p: two-pole band pass filter (12dB/octave). brf_2p: two-pole band rejection filter (12dB/octave). pkf_2p: two-pole peak filter (12dB/octave). lpf_4p: four-pole low pass filter (24dB/octave). hpf_4p: four-pole high pass filter (24dB/octave). lpf_6p: six-pole low pas filter (36dB/octave). hpf_6p: six-pole high pass filter (36dB/octave). comb: comb filter pink: pink filter string lpf_1p, hpf_1p, bpf_1p, brf_1p, apf_1p, lpf_2p, hpf_2p, bpf_2p, brf_2p, pkf_2p, lpf_4p, hpf_4p, lpf_6p, hpf_6p, comb, pink cutoff= cutoff2= The filter cutoff frequency, in Hz. If the cutoff is not specified, the filter will be disabled, with the consequent CPU drop in the player. float 0 to SR/2 cutoff_onccN= cutoff2_onccN= The variation in the cutoff frequency when MIDI continuous controller N is received, in cents. integer -9600 to 9600 cents cutoff_smoothccN= cutoff2_smoothccN= The smooth factor defines how smooth the change is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer -9600 to 9600 cents cutoff_stepccN= cutoff2_stepccN= The step factor sets in what steps that the variation is introduced. integer -9600 to 9600 cents cutoff_curveccN= cutoff2_curveccN= Select a curve defined internally or in a section. integer ? cutoff_chanaft= cutoff2_chanaft= The variation in the cutoff frequency when MIDI channel aftertouch messages are received, in cents. integer -9600 to 9600 cents cutoff_polyaft= cutoff2_polyaft= The variation in the cutoff frequency when MIDI polyphonic aftertouch messages are received, in cents. integer -9600 to 9600 cents resonance= resonance2= The filter cutoff resonance value, in dB. float 0 to 40 dB resonance_onccN= resonance2_onccN= The filter cutoff resonance value modulated by MIDI continuous controller N, in dB. float 0 to 40 dB resonance_smoothccN= resonance2_smoothccN= The smooth factor defines how smooth the modulation is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. float 0 to 40 dB resonance_stepccN= resonance2_stepccN= The step factor sets in what steps that the modulation is introduced. float 0 to 40 dB resonance_curveccN= resonance2_curveccN= Select a curve defined internally or in a section. integer 0 to 4294967296 fil_keytrack= fil2_keytrack= Filter keyboard tracking (change on cutoff for each key) in cents. integer 0 to 1200 cents fil_keycenter= fil2_keycenter= Center key for filter keyboard tracking. In this key, the filter keyboard tracking will have no effect. integer 0 to 127 fil_veltrack= fil2_veltrack= Filter velocity tracking, represents how much the cutoff changes with incoming note velocity. integer -9600 to 9600 cents fil_random= fil2_random= Random cutoff added to the region, in cents. integer 0 to 9600 cents Table 1.10 Envelope Generators The first seven EGs might already be in use by the player. To be compatible across different players start with EG number 8. Opcode Description Type Range egN_timeX= Set the time of the node X in the envelope generator N to the specified value. float 0 to 100 seconds egN_timeX_onccY= Set the time of the node X in the envelope generator N to the specified value modulated by MIDI continuous controller X. float 0 to 100 seconds egN_levelX= Sets the level of the node X in the envelope generator N to the specified value. float 0 to 1 egN_levelX_onccY= Sets the level of the node X in the envelope generator N to the specified value modulated by MIDI continuous controller X. float 0 to 1 egN_shapeX= Sets the shape of the segment X in the flexible envelope generator N to one of the predefined shapes. float 0 to 1 egN_curveX= Defines the curve of the segment X in the envelope generator N. float 0 to 1 egN_sustain= Sets the specified node as the sustain node for the envelope generator N. integer 0 to 100 egN_loop= Sets the specified node as the loop node for the envelope generator N. integer 0 to 100 egN_loop_count= Defines the number of repeats for the loop in the envelope generator N. integer 0 to 4294967296 egN_volume= Patch envelope generator N to the amplifier. The EGs normalized output will be multiplied by the opcode value and added to the destination. float -144 to 6 dB egN_amplitude= -\"- float 0 to 100 % egN_pan= egN_width= egN_position= -\"- float -100 to 100 % egN_pan_curve= egN_pan_curveccX= Select a curve defined internally or in a section. integer ? egN_volume_onccX= Patch envelope generator N to the amplifier. The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. float -144 to 6 dB egN_amplitude_onccX= -\"- float 0 to 100 % egN_pan_onccX= egN_width_onccX= egN_position_onccX= -\"- float -100 to 100% egN_freq_lfoX= Patch envelope generator N to LFO X. The EGs normalized output will be multiplied by the opcode value and added to the destination. float 0 to 20 Hz egN_depth_lfoX= egN_depthadd_lfoX= -\"- integer -1200 to 1200 cents egN_pitch= Patch envelope generator N to the pitch. The EGs normalized output will be multiplied by the opcode value and added to the destination. integer -9600 to 9600 cents egN_pitch_onccX= Patch envelope generator N to the pitch. The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. integer -9600 to 9600 cents egN_cutoff= egN_cutoff2= Patch envelope generator N to the filter. The EGs normalized output will be multiplied by the opcode value and added to the destination. integer -9600 to 9600 cents egN_resonance= egN_resonance2= -\"- float 0 to 40dB egN_cutoff_onccX= egN_cutoff2_onccX= Patch envelope generator N to the filter. The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. integer -9600 to 9600 cents egN_resonance_onccX= egN_resonance2_onccX= -\"- float 0 to 40 dB egN_eq1freq= egN_eq2freq= egN_eq3freq= Patch envelope generator N to the per voice equalizer. The EGs normalized output will be multiplied by the opcode value and added to the destination. float 0 to 30000 Hz egN_eq1bw= egN_eq2bw= egN_eq3bw= -\"- float 0.001 to 4 octaves egN_eq1gain= egN_eq2gain= egN_eq3gain= -\"- float -96 to 24 dB egN_eq1freq_onccX= egN_eq2freq_onccX= egN_eq3freq_onccX= Patch envelope generator N to the per voice equalizer. The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. float 0 to 30000 Hz egN_eq1bw_onccX= egN_eq2bw_onccX= egN_eq3bw_onccX= -\"- float 0.001 to 4 octaves egN_eq1gain_onccX= egN_eq2gain_onccX= egN_eq3gain_onccX= -\"- float -96 to 24 dB egN_decim= egN_bitred= egN_rectify= egN_ringmod= egN_noiselevel= egN_noisestep= egN_noisetone= egN_driveshape= Patch envelope generator N to effects. The EGs normalized output will be multiplied by the opcode value and added to the destination. ? ? egN_decim_onccX= egN_bitred_onccX= egN_rectify_onccX= egN_ringmod_onccX= egN_noiselevel_onccX= egN_noisestep_onccX= egN_noisetone_onccX= egN_driveshape_onccX= The EGs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X ? ? Table 1.11 Low-Frequency Oscillators The first seven LFOs might already be in use by the player. To be compatible across different players start with LFO number 8. Opcode Description Type Range lfoN_freq= Defines the frequency for the LFO N, in Hz. float 0 to 20 Hz lfoN_freq_onccX= Defines the frequency variation modulated by MIDI continuous controller X for the LFO N, in Hz. float 0 to 20 Hz lfoN_freq_smoothccX= The smooth factor defines how smooth MIDI continuous controller X modulation is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_freq_stepccX= The step factor sets in what steps that variation is introduced. float 0 to 20 Hz lfoN_delay= Sets a delay time from the region instantiation to the LFO N starts working, in seconds. float 0 to 100 seconds lfoN_delay_onccX= Sets a delay time from the region instantiation to the LFO N starts working modulated by MIDI continuous controller X, in seconds. float 0 to 100 seconds lfoN_fade= Defines a fade-in ramp from region instantiation for the LFO N output, in seconds. float 0 to 100 seconds lfoN_fade_onccX= Defines a fade-in ramp from the region instantiation for the LFO N output modulated by MIDI continuous controller X, in seconds. float 0 to 100 seconds lfoN_depth= lfoN_depth_onccN= lfoN_phase= Sets the initial phase of the LFO N. float 0 to 360 degrees lfoN_phase_onccX= Sets the initial phase of LFO N modulated by MIDI continuous controller X. float 0 to 360 degrees lfoN_count= Defines a cycle count for the LFO N. After that cycle count, the LFO will stop. Default is infinite. integer 0 to 4294967296 lfoN_wave= Set the waveform for LFO N. The wave pool is player dependant, but the following waveforms are mandatory: 0: triangle 1: sine 2: pulse 75% 3: square (pulse 50%) 4: pulse 25% 5: pulse 12.5% 6: saw up 7: saw down integer 0 to 4294967296 lfoN_steps= Turns the LFO N into a step sequencer, with a number of steps specified in the value. integer 0 to 4294967296 lfoN_stepX= Defines the level of step X in the LFO N. float 0 to 1 lfoN_smooth= Sets the smoothing for the LFO N output. ? ? lfoN_smooth_onccX= Sets the smoothing for the LFO N output modulated by MIDI continuous controller X. ? ? lfoN_volume= Patch LFO N to amplifier. The LFOs normalized output will be multiplied by the opcode value and added to the destination. float -144 to 6 dB lfoN_amplitude= -\"- float 0 to 100 % lfoN_pan= lfoN_width= lfoN_position= -\"- float -100 to 100 % lfoN_volume_onccX= Patch LFO N to amplifier. The LFOs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. float -144 to 6 dB lfoN_amplitude_onccX= -\"- float 0 to 100 % lfoN_pan_onccX= lfoN_width_onccX= lfoN_position_onccX= -\"- float -100 to 100 % lfoN_volume_smoothccX= lfoN_amplitude_smoothccX= lfoN_pan_smoothccX= lfoN_width_smoothccX= lfoN_position_smoothccX= The smooth factor defines how smooth the modulation is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_volume_stepccX= lfoN_amplitude_stepccX= lfoN_pan_stepccX= lfoN_width_stepccX= lfoN_position_stepccX= The step factor sets in what steps that modulation is introduced. integer 0 to 4294967296 lfoN_freq_lfoX= Patch LFO N to LFO X. The LFOs normalized output will be multiplied by the opcode value and added to the destination. float 0 to 20 Hz lfoN_depth_lfoX= lfoN_depthadd_lfoX= -\"- integer -1200 to 1200 cents lfoN_pitch= Patch LFO N to the pitch. The LFOs normalized output will be multiplied by the opcode value and added to the destination. integer -9600 to 9600 cents lfoN_pitch_onccX= Pitch of LFO N modulated by MIDI continuous controller X. ? ? lfoN_pitch_smoothccX= Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer lfoN_pitch_stepccX= The step factor sets in what steps that variation is introduced. integer 0 to 4294967296 lfoN_cutoff= lfoN_cutoff2= Patch LFO N to the filter. The LFOs normalized output will be multiplied by the opcode value and added to the destination. integer -9600 to 9600 cents lfoN_resonance= lfoN_resonance2= -\"- float 0 to 40 dB lfoN_cutoff_onccX= lfoN_cutoff2_onccX= Patch LFO N to the filter. The LFOs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. integer -9600 to 9600 cents lfoN_resonance_onccX= lfoN_resonance2_onccX= -\"- float 0 to 40 dB lfoN_cutoff_smoothccX= lfoN_cutoff2_smoothccX= lfoN_resonance_smoothccX= lfoN_resonance2_smoothX= The smooth factor defines how smooth the change is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_cutoff_stepccX= lfoN_cutoff2_stepccX= lfoN_resonance_stepccX= lfoN_resonance2_stepccX= The step factor sets in what steps that variation is introduced. integer 0 to 4294967296 lfoN_eq1freq= lfoN_eq2freq= lfoN_eq3freq= Patch LFO N to the per voice equalizer. The LFOs normalized output will be multiplied by the opcode value and added to the destination. float 0 to 30000 Hz lfoN_eq1bw= lfoN_eq2bw= lfoN_eq3bw= -\"- float 0.001 to 4 octaves lfoN_eq1gain= lfoN_eq2gain= lfoN_eq3gain= -\"- float -96 to 24 dB lfoN_eq1freq_onccX= lfoN_eq2freq_onccX= lfoN_eq3freq_onccX= Patch LFO N to the per voice equalizer. The LFOs normalized output will be multiplied by the opcode value and added to the destination in addition to being modulated by MIDI continuous controller X. float 0 to 30000 Hz lfoN_eq1bw_onccX= lfoN_eq2bw_onccX= lfoN_eq3bw_onccX= -\"- float 0.001 to 4 octaves lfoN_eq1gain_onccX= lfoN_eq2gain_onccX= lfoN_eq3gain_onccX= -\"- float -96 to 24 dB lfoN_eq1freq_smoothccX= lfoN_eq2freq_smoothccX= lfoN_eq3freq_smoothccX= lfoN_eq1bw_smoothccX= lfoN_eq2bw_smoothccX= lfoN_eq3bw_smoothccX= lfoN_eq1gain_smoothccX= lfoN_eq2gain_smoothccX= lfoN_eq3gain_smoothccX= The smooth factor defines how smooth the change is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_eq1freq_stepccX= lfoN_eq2freq_stepccX= lfoN_eq3freq_stepccX= lfoN_eq1bw_stepccX= lfoN_eq2bw_stepccX= lfoN_eq3bw_stepccX= lfoN_eq1gain_stepccX= lfoN_eq2gain_stepccX= lfoN_eq3gain_stepccX= The step factor sets in what steps that variation is introduced. integer 0 to 4294967296 lfoN_decim= lfoN_bitred= lfoN_noiselevel= lfoN_noisestep= lfoN_noisetone= lfoN_drive= Patch LFO N to effects. ? ? lfoN_decim_onccX= lfoN_bitred_onccX= lfoN_noiselevel_onccX= lfoN_noisestep_onccX= lfoN_noisetone_onccX= lfoN_drive_onccX= Modulated by MIDI continuous control N. ? ? lfoN_decim_smoothccX= lfoN_bitred_smoothccX= lfoN_noiselevel_smoothccX= lfoN_noisestep_smoothccX= lfoN_noisetone_smoothccX= lfoN_drive_smoothccX= The smooth factor defines how smooth the change is. Smooth is a low pass filter on speed of parameter changes and its in milliseconds. integer ? lfoN_decim_stepccX= lfoN_bitred_stepccX= lfoN_noiselevel_stepccX= lfoN_noisestep_stepccX= lfoN_noisetone_stepccX= lfoN_drive_stepccX= The step factor sets in what steps that variation is introduced. ? ? Table 1.12 Equalizer Note that the equalizers are monophonic (i.e. they apply to all notes playing) while these are polyphonic (i.e. they apply per voice). Opcode Description Type Range eq1_freq= eq2_freq= eq3_freq= Frequency of the equalizer band, in Hz. float 0 to 30000 Hz eq1_freq_onccN= eq2_freq_onccN= eq3_freq_onccN= Frequency change of the equalizer band modulated by MIDI continuous control N, in Hz. float -30000 to 30000 Hz eq1_vel2freq= eq2_vel2freq= eq3_vel2freq= Frequency change of the equalizer band with MIDI velocity, in Hz. float -30000 to 30000 Hz eq1_bw= eq2_bw= eq3_bw= Bandwidth of the equalizer band, in octaves. float 0.001 to 4 octaves eq1_bw_onccN= eq2_bw_onccN= eq3_bw_onccN= Bandwidth change of the equalizer band modulated by MIDI continuous control N, in octaves. float -4 to 4 octaves eq1_gain= eq2_gain= eq3_gain= Gain of the equalizer band, in dB. float -96 to 24 dB eq1_gain_onccN= eq2_gain_onccN= eq3_gain_onccN= Gain change of the equalizer band modulated by MIDI continuous control N, in dB. float -96 to 24 dB eq1_vel2gain= eq2_vel2gain= eq3_vel2gain= Gain change of the equalizer band with MIDI velocity, in dB. float -96 to 24 dB Table 1.13 Effects (SFZ v2) All effects should be prefaced with the header. Opcode Description Type Range Table 1.14 Effects (SFZ v1) Opcode Description Type Range effect1= Level of effect1 send (reverb). float 0 to 100 % effect2= Level of effect2 send (chorus). float 0 to 100 % Table 1.15 Amplifier EG (SFZ v1) These have been deprecated. Use the much more flexible EGs in Table 1.10 instead. Opcode Description Type Range ampeg_delay= Amplifier EG delay time, in seconds. This is the time elapsed from note on to the start of the Attack stage. float 0 to 100 seconds ampeg_start= Amplifier EG start level, in percentage. float 0 to 100 % ampeg_attack= Amplifier EG attack time, in seconds. float 0 to 100 seconds ampeg_hold= Amplifier EG hold time, in seconds. During the hold stage, EG output will remain at its maximum value. float 0 to 100 seconds ampeg_decay= Amplifier EG decay time, in seconds. float 0 to 100 seconds ampeg_sustain= Amplifier EG sustain level, in percentage. float 0 to 100 % ampeg_release= Amplifier EG release time (after note release), in seconds. float 0 to 100 seconds ampeg_vel2delay= Velocity effect on amplifier EG delay time, in seconds. float -100 to 100 seconds ampeg_vel2attack= Velocity effect on amplifier EG attack time, in seconds. float -100 to 100 seconds ampeg_vel2hold= Velocity effect on amplifier EG hold time, in seconds. float -100 to 100 seconds ampeg_vel2decay= Velocity effect on amplifier EG decay time, in seconds float -100 to 100 seconds ampeg_vel2sustain= Velocity effect on amplifier EG sustain level, in percentage. float -100 to 100 % ampeg_vel2release= Velocity effect on amplifier EG release time, in seconds. float -100 to 100 seconds ampeg_delay_onccN= Amplifier EG delay time added on MIDI control N, in seconds. float -100 to 100 seconds ampeg_start_onccN= Amplifier EG start level added on MIDI control N, in percentage. float -100 to 100 % ampeg_attack_onccN= Amplifier EG attack time added on MIDI control N, in seconds. float -100 to 100 second ampeg_hold_onccN= Amplifier EG hold time added on MIDI control N, in seconds. float -100 to 100 seconds ampeg_decay_onccN= Amplifier EG decay time added on MIDI control N, in seconds. float -100 to 100 seconds ampeg_sustain_onccN= Amplifier EG sustain level added on MIDI control N, in percentage. float -100 to 100 % ampeg_release_onccN= Amplifier EG release time added on MIDI control N, in seconds. float -100 to 100 seconds Table 1.16 Amplifier LFO (SFZ v1) These have been deprecated. Use the much more flexible LFOs in Table 1.11 instead. Opcode Description Type Range amplfo_delay= The time before the Amplifier LFO starts oscillating, in seconds. float 0 to 100 seconds amplfo_delay_onccN= The time before the Amplifier LFO starts oscillating modulated by MIDI continuous controller N, in seconds. float 0 to 100 seconds amplfo_fade= Amplifier LFO fade-in effect time, in seconds. float 0 to 100 seconds amplfo_fade_onccN= Amplifier LFO fade-in effect time modulated by MIDI continuous controller N, in seconds. float 0 to 100 seconds amplfo_freq= Amplifier LFO frequency, in hertz. float 0 to 20 hertz amplfo_freq_onccN= Amplifier LFO frequency change when MIDI continuous controller N is received, in hertz. float -200 to 200 hertz amplfo_freqchanaft= Amplifier LFO frequency change when channel aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz amplfo_freqpolyaft= Amplifier LFO frequency change when polyphonic aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz amplfo_depth= Amplifier LFO depth, in decibels. float -10 to 10 dB amplfo_depth_onccN= Amplifier LFO depth when MIDI continuous controller N is received, in decibels. float -10 to 10 dB amplfo_depthchanaft= Amplifier LFO depth when polyphonic aftertouch MIDI messages are received, in cents. float -10 to 10 dB amplfo_depthpolyaft= Amplifier LFO frequency change when polyphonic aftertouch MIDI messages are received, in hertz. float -10 to 10 dB Table 1.17 Filter EG (SFZ v1) These have been deprecated. Use the much more flexible EGs in Table 1.10 instead. Opcode Description Type Range fileg_delay= Filter EG delay time, in seconds. This is the time elapsed from note on to the start of the Attack stage. float 0 to 100 seconds fileg_start= Filter EG start level, in percentage. float 0 to 100 % fileg_attack= Filter EG attack time, in seconds. float 0 to 100 seconds fileg_hold= Filter EG hold time, in seconds. During the hold stage, EG output will remain at its maximum value. float 0 to 100 seconds fileg_decay= Filter EG decay time, in seconds. float 0 to 100 seconds fileg_sustain= Filter EG sustain level, in percentage. float 0 to 100 % fileg_release= Filter EG release time (after note release), in seconds. float 0 to 100 seconds fileg_depth= Depth or the filter EG, in cents. integer -12000 to 12000 cents fileg_vel2delay= Velocity effect on filter EG delay time, in seconds. float -100 to 100 seconds fileg_vel2attack= Velocity effect on filter EG attack time, in seconds. float -100 to 100 seconds fileg_vel2hold= Velocity effect on filter EG hold time, in seconds. float -100 to 100 seconds fileg_vel2decay= Velocity effect on filter EG decay time, in seconds. float -100 to 100 seconds fileg_vel2sustain= Velocity effect on filter EG sustain level, in percentage. float -100 to 100 % fileg_vel2release= Velocity effect on filter EG release time, in seconds. float -100 to 100 seconds fileg_vel2depth= integer -12000 to 12000 cents fileg_delay_onccN= float -100 to 100 seconds fileg_start_onccN= float -100 to 100 seconds fileg_attack_onccN= float -100 to 100 seconds fileg_hold_onccN= float -100 to 100 seconds fileg_decay_onccN= float -100 to 100 seconds fileg_sustain_onccN= float -100 to 100 % fileg_release_onccN= float -100 to 100 seconds fileg_depth_onccN= integer -12000 to 12000 cents Table 1.18 Filter LFO (SFZ v1) These have been deprecated. Use the much more flexible LFOs in Table 1.11 instead. Opcode Description Type Range fillfo_delay= The time before the filter LFO starts oscillating, in seconds. float 0 to 100 seconds fillfo_delay_onccN= float -100 to 100 seconds fillfo_fade= Filter LFO fade-in effect time. float 0 to 100 seconds fillfo_fade_onccN= float -100 to 100 seconds fillfo_freq= Filter LFO frequency, in hertz. float 0 to 20 hertz fillfo_freq_onccN= Filter LFO frequency change when MIDI continuous controller N is received, in hertz. float -200 to 200 hertz fillfo_freqchanaft= Filter LFO frequency change when channel aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz fillfo_freqpolyaft= Filter LFO frequency change when polyphonic aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz fillfo_depth= Filter LFO depth, in cents. integer -1200 to 1200 cents fillfo_depth_onccN= Filter LFO depth when MIDI continuous controller N is received, in cents. integer -1200 to 1200 cents fillfo_depthchanaft= Filter LFO depth when channel aftertouch MIDI messages are received, in cents. integer -1200 to 1200 cents fillfo_depthpolyaft= Filter LFO depth when polyphonic aftertouch MIDI messages are received, in cents. integer -1200 to 1200 cents Table 1.19 Pitch EG (SFZ v1) These have been deprecated. Use the much more flexible EGs in Table 1.10 instead. Opcode Description Type Range pitcheg_delay= Pitch EG delay time, in seconds. This is the time elapsed from note on to the start of the Attack stage. float 0 to 100 seconds pitcheg_start= Pitch EG start level, in percentage. float 0 to 100 % pitcheg_attack= Pitch EG attack time, in seconds. float 0 to 100 seconds pitcheg_hold= Pitch EG hold time, in seconds. During the hold stage, EG output will remain at its maximum value. float 0 to 100 seconds pitcheg_decay= Pitch EG decay time, in seconds. float 0 to 100 seconds pitcheg_sustain= Pitch EG release time (after note release), in seconds. float 0 to 100 % pitcheg_release= Pitch EG release time (after note release), in seconds. float 0 to 100 seconds pitcheg_depth= Depth for the pitch EG, in cents. integer -12000 to 12000 cents pitcheg_vel2delay= Velocity effect on pitch EG delay time, in seconds. float -100 to 100 seconds pitcheg_vel2attack= Velocity effect on pitch EG attack time, in seconds. float -100 to 100 seconds pitcheg_vel2hold= Velocity effect on pitch EG hold time, in seconds. float -100 to 100 seconds pitcheg_vel2decay= Velocity effect on pitch EG decay time, in seconds. float -100 to 100 seconds pitcheg_vel2sustain= Velocity effect on pitch EG sustain level, in percentage. float -100 to 100 % pitcheg_vel2release= Velocity effect on pitch EG release time, in seconds. float -100 to 100 seconds pitcheg_vel2depth= Velocity effect on pitch EG depth, in cents. integer -12000 to 12000 cents pitcheg_delay_onccN= float -100 to 100 seconds pitcheg_start_onccN= float -100 to 100 seconds pitcheg_attack_onccN= float -100 to 100 seconds pitcheg_hold_onccN= float -100 to 100 seconds pitcheg_decay_onccN= float -100 to 100 seconds pitcheg_sustain_onccN= float -100 to 100 % pitcheg_release_onccN= float -100 to 100 seconds pitcheg_depth_onccN= integer -12000 to 12000 cents Table 1.20 Pitch LFO (SFZ v1) These have been deprecated. Use the much more flexible LFOs in Table 1.11 instead. Opcode Description Type Range pitchlfo_delay= The time before the Pitch LFO starts oscillating, in seconds. float 0 to 100 seconds pitchlfo_delay_onccN= float -100 to 100 seconds pitchlfo_fade= Pitch LFO fade-in effect time. float 0 to 100 seconds pitchlfo_fade_onccN= float -100 to 100 seconds pitchlfo_freq= Pitch LFO frequency, in hertz. float 0 to 20 hertz pitchlfo_freq_onccN= Pitch LFO frequency change when MIDI continuous controller N is received, in hertz. float -200 to 200 hertz pitchlfo_freqchanaft= Pitch LFO frequency change when channel aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz pitchlfo_freqpolyaft= Pitch LFO frequency change when polyphonic aftertouch MIDI messages are received, in hertz. float -200 to 200 hertz pitchlfo_depth= Pitch LFO depth, in cents. integer -1200 to 1200 cents pitchlfo_depth_onccN= Pitch LFO depth when MIDI continuous controller N is received, in cents. integer -1200 to 1200 cents pitchlfo_depthchanaft= Pitch LFO depth when channel aftertouch MIDI messages are received, in cents. integer -1200 to 1200 cents pitchlfo_depthpolyaft= Pitch LFO depth when polyphonic aftertouch MIDI messages are received, in cents. integer -1200 to 1200 cents","title":"Table 1.7 Amplifier"},{"location":"en/linuxsampler/sfz/#table-121-curve","text":"The first six curves are predefined by the player and usually player specific if implemented, custom curve number 7 and up can be defined using the <curve> header. Opcode Description Type Range vN= Define normalized values on curve. float 0 to 1","title":"Table 1.21 Curve"},{"location":"en/linuxsampler/sfz/#table-122-global","text":"There can be one <global> header in a file. Their settings are global for the whole file. The following opcodes can only be defined in the global header. Opcode Description Type Range polyphony= Limits the polyphony to number of voices. The default is infinite or maximal number of voices the player can handle, whichever comes first. integer n/a sustain_sw= Enable/disable the sustain pedal. string on, off","title":"Table 1.22 Global"},{"location":"en/news/","text":"{{ blog_content }}","title":"Latest News"},{"location":"en/news/posts/2017-07-02-new-website-launched/","text":"We're proud to announce a new website for the DIY E-Drums Project! Responsive design making the website available to mobile devices. Utilizes Bootstrap for easy skinning. Built on Jekyll . Allows for comments on news posts (let us know what you think!) Most content is authored in Markdown format. Updates to the site can now be submitted to the GitHub repo","title":"New Website Launched"},{"location":"en/roland/adding_pads/","text":"Simplified Instructions for expanding the TD-20 (or TD-12) with an external trigger Make sure the pads plugged into your external trigger are set to channel 11. On the external trigger, set the head and rim notes to notes that are logical and easy to remember (ie head:40 and rim:41). Do this for boths pads (different notes for each of course). Press \"Pattern\" on the TD-20, then scroll up using the jogwheel until \"Part\" appears above the F2 key (if it isn't already there of course). Press F2 (Part), then F3 (Perc). Select the kit you want then press F5 to edit. You are now in the \"Percussion Set Edit\" screen. Press F2 (edit). Go to \"perc note\" and select the note you assigned to the head or rim (depending on what you want to use). You will need to do this for each head and rim of each pad you want to use. When you're done you can press List in the Percussion set edit screen to choose what instrument you wish to assign to your pads head or rim. You can also change the settings for each instruments Volume, Panning, Pitch, Decay, Reverb, Chorus, and CC. All editing for the pads plugged into your external trigger is now done on the TD-20 (except for trigger settings like sens. threshold etc.). Source: VDrums.com Forum","title":"Adding pads to Roland TD-12 and TD-20"},{"location":"en/roland/adding_pads/#simplified-instructions-for-expanding-the-td-20-or-td-12-with-an-external-trigger","text":"Make sure the pads plugged into your external trigger are set to channel 11. On the external trigger, set the head and rim notes to notes that are logical and easy to remember (ie head:40 and rim:41). Do this for boths pads (different notes for each of course). Press \"Pattern\" on the TD-20, then scroll up using the jogwheel until \"Part\" appears above the F2 key (if it isn't already there of course). Press F2 (Part), then F3 (Perc). Select the kit you want then press F5 to edit. You are now in the \"Percussion Set Edit\" screen. Press F2 (edit). Go to \"perc note\" and select the note you assigned to the head or rim (depending on what you want to use). You will need to do this for each head and rim of each pad you want to use. When you're done you can press List in the Percussion set edit screen to choose what instrument you wish to assign to your pads head or rim. You can also change the settings for each instruments Volume, Panning, Pitch, Decay, Reverb, Chorus, and CC. All editing for the pads plugged into your external trigger is now done on the TD-20 (except for trigger settings like sens. threshold etc.). Source: VDrums.com Forum","title":"Simplified Instructions for expanding the TD-20 (or TD-12) with an external trigger"},{"location":"en/roland/dsub25_cable/","text":"Source: MisterMR's VDrums.com forum topic TD-9-11-15-25 ( C5400133R0 ): TD-4 (5100003405): HD-1 (C5400126R0): TD-9-11-15-25 Custom:","title":"Roland DSub25 Cable"},{"location":"en/roland/dynamic/","text":"Zero out all your group faders. Literally place them on zero so you have room to go up and down. Go in your mixer and change all the volumes of the individual pads and rims to 80. Change the kit volume to 127 Turn off your compressor, EQ, and Ambience Go in to the trigger menu and adjust your sensitivity so your absolute loudest hits peak the meter. This goes for both head and rim. Adjust the threshold so your lightest hits are set-up correctly. At this point you should have the maximum amount of dynamic range set up for your kit. If you ever had machine gunning it should be just about eliminated. Adjust the curves for each of the pads to work with your playing style. This is where you will hear those playing dynamics change a bit. Linear is just that... Linear. EXP1&2 will remove the middle dynamics and make even medium to loud hits kind of quiet. LOG1&2 will bring up the middle dynamics and make middle to hard hits louder. Spline will just about remove the middle dynamics and turn your playing dynamics is to an on/off switch. That's a bit extreme of a definition, but it works great for toms and the ride bow, IMO. And then there is LOUD1&2. These remove the quiet dynamics and bring up the volume of all your low to mid hits. Go back in to the mixer and adjust the individual pad volumes so your drums and cymbals all sound correct in their volume relative to eachother. After that you can get in to the compressor, EQ, and ambiance. Source: VDrums.com forum","title":"Dynamic"},{"location":"en/roland/trigger_settings/","text":"BASIC Pad Sensitivity (1 - 32) You can adjust the sensitivity of the pads to accommodate your personal playing style. This allows you to have more dynamic control over the sound volume, based on how hard you play. Higher sensitivity allows the pad to produce a loud volume even when played softly. Lower sensitivity will keep the pad producing a low volume even when played forcefully. Threshold (Minimum level for the pad, 0 - 31) This setting allows a trigger signal to be received only when the pad is above a determined force level (velocity). This can be used to prevent a pad from sounding because of vibrations from other pads. In the following example, B will sound but A and C will not sound. When set to a higher value, no sound is produced when the pad is struck lightly. Gradually raise the \u201cThreshold\u201d value while striking the pad. Check this and adjust accordingly. Repeat this process until you get the perfect setting for your playing style. Velocity Curve (How Playing Dynamics Changes the Volume) This setting allows you to control the relation between playing velocity (striking force) and changes in volume. Adjust this curve until the response feels as natural as possible. LINEAR The standard setting. This produces the most natural correspondence between playing dynamics and volume change. EXP1, EXP2 Compared to LINEAR, strong dynamics produce a greater change. LOG1, LOG2 Compared to LINEAR, a soft playing produces a greater change. SPLINE Extreme changes are made in response to playing dynamics. LOUD1, LOUD2 Very little dynamic response, making it easy to maintain strong volume levels. If using drum triggers, these settings help maintain stable levels. XTALK (Eliminate Crosstalk Between Pads) When two pads are mounted on the same stand, hitting one pad may trigger the sound from another pad unintentionally. (This is called crosstalk ). Eliminate this by adjusting Xtalk Cancel on the pad that is sounding inadvertently. In some cases, you can prevent crosstalk between two pads by increasing the distance between them. Crosstalk Example: If you hit the snare pad and the tom 1 also sounds Set the snare and tom 1 to the same XTALK GROUP. Raise the \u201cXTALK CANCEL\u201d for the pad being used for the tom 1. The tom 1 pad will be less prone to receive crosstalk from other pads. With a setting \u201cOFF,\u201d crosstalk prevention will not work. If the value is set too high, and two pads are played simultaneously, the one that is struck less forcefully may not sound. Be careful and set this parameter to the minimum value required to prevent crosstalk. ADVANCE (Advanced Trigger Parameters) Scan Time (Trigger Signal Detection Time, 0 - 4.0 ms) Specifies the detection time for the trigger signal. Since the rise time of the trigger signal waveform may differ slightly depending on the characteristics of each pad or acoustic drum trigger (drum pickup), you may notice that identical hits (velocity) may produce sound at different volumes. If this occurs, you can adjust the \u201cScan Time\u201d so that your way of playing can be detected more precisely. While repeatedly hitting the pad at a constant force, gradually raise the Scan Time value from 0 msec, until the resulting volume stabilizes at the loudest level. At this setting, try both soft and loud strikes, and make sure that the volume changes appropriately. As the value is set higher, the time it takes for the sound to be played increases. Set this to the lowest value possible. Retrigger Cancel (Detecting Trigger Signal Attenuation, 1 - 16) This setting prevents spurious re-triggering. Important if you are using acoustic drum triggers. Such triggers can produce altered waveforms, which may also cause inadvertent sounding at Point A in the following figure ( Retrigger ). This occurs in particular at the decaying edge of the waveform. Retrigger Cancel detects such distortion in and prevents retriggering from occurring. While repeatedly striking the pad, raise the \u201cRetrig Cancel\u201d value until retriggering no longer occurs. Although setting this to a high value prevents retriggering, it then becomes easy for sounds to be omitted when the drums played fast (roll etc.). Set this to the lowest value possible while still ensuring that there is no retriggering. You can also eliminate this problem of retriggering with the Mask Time setting. Mask Time does not detect trigger signals if they occur within the specified amount of time after the previous trigger signal was received. Retrigger Cancel detects the attenuation of the trigger signal level, and triggers the sound after internally determining which trigger signals were actually generated when the head was struck, while weeding out the other false trigger signals that need not trigger a sound. Mask Time (Double Triggering Prevention, 0 - 64 ms) This setting prevents double triggering. When playing a kick trigger the beater can bounce back and hit the head a second time immediately after the intended note\u2014with acoustic drums sometimes the beater stays against the head\u2014this causes a single hit to \u201cdouble trigger\u201d (two sounds instead of one). The Mask Time setting helps to prevent this. Once a pad has been hit, any additional trigger signals occurring within the specified \u201cMask Time\u201d (0\u201364msec) will be ignored. Adjust the \u201cMask Time\u201d value while playing the pad. When using a kick trigger, try to let the beater bounce back and hit the head very quickly, then raise the \u201cMask Time\u201d value until there are no more sounds made by the beater rebound. When set to a high value, it will be difficult to play very quickly. Set this to as low a value as you can. If two or more sounds are being produced when you strike the head just once, then adjust Retrig Cancel. Rim Gain (Rim/Edge Dynamic Response, 0 \u2013 3.2) When a PD-125/120/105/85/80R, PD-9/8/7, CY series pad, VH-12/11, or RT-5S (trigger) is connected, you can adjust the relation between your playing velocity (force) on the rim/edge and the resulting volume level. Higher value allows the rim/edge to produce a loud volume even when played softly. Lower value will keep the rim/edge producing a low volume even when played forcefully. Rim Shot Adjust (Rim Shots Response, 0 \u2013 8.0) When a PD-125/120/105/85/80R or RT-5S (trigger) is connected, you can adjust the sensitivity of the rim response. There are some cases that you have a rim sound unexpectedly when you hit the head strongly. You can improve this situation with decreasing the value of \u201cRimShot Adjust.\u201d When you set the value too small, it might be difficult to play the rim sound. XStick Thrshld (Cross Stick Threshold, 0 \u2013 127) When a PD-125/120/105/85/80R or RT-5S (trigger) is connected, you can determine the \u201ccross over point\u201d between the cross stick and a rim shot sounds. Setting this to a higher value makes it easier to get cross stick sounds. When set to \u201c0,\u201d playing a cross stick produces the open rim shot sound. Increasing the value excessively may cause the cross stick to sound as well when the open rim shot is played.","title":"Trigger Settings"},{"location":"en/roland/trigger_settings/#basic","text":"","title":"BASIC"},{"location":"en/roland/trigger_settings/#pad-sensitivity-1-32","text":"You can adjust the sensitivity of the pads to accommodate your personal playing style. This allows you to have more dynamic control over the sound volume, based on how hard you play. Higher sensitivity allows the pad to produce a loud volume even when played softly. Lower sensitivity will keep the pad producing a low volume even when played forcefully.","title":"Pad Sensitivity (1 - 32)"},{"location":"en/roland/trigger_settings/#threshold-minimum-level-for-the-pad-0-31","text":"This setting allows a trigger signal to be received only when the pad is above a determined force level (velocity). This can be used to prevent a pad from sounding because of vibrations from other pads. In the following example, B will sound but A and C will not sound. When set to a higher value, no sound is produced when the pad is struck lightly. Gradually raise the \u201cThreshold\u201d value while striking the pad. Check this and adjust accordingly. Repeat this process until you get the perfect setting for your playing style.","title":"Threshold (Minimum level for the pad, 0 - 31)"},{"location":"en/roland/trigger_settings/#velocity-curve-how-playing-dynamics-changes-the-volume","text":"This setting allows you to control the relation between playing velocity (striking force) and changes in volume. Adjust this curve until the response feels as natural as possible. LINEAR The standard setting. This produces the most natural correspondence between playing dynamics and volume change. EXP1, EXP2 Compared to LINEAR, strong dynamics produce a greater change. LOG1, LOG2 Compared to LINEAR, a soft playing produces a greater change. SPLINE Extreme changes are made in response to playing dynamics. LOUD1, LOUD2 Very little dynamic response, making it easy to maintain strong volume levels. If using drum triggers, these settings help maintain stable levels.","title":"Velocity Curve (How Playing Dynamics Changes the Volume)"},{"location":"en/roland/trigger_settings/#xtalk-eliminate-crosstalk-between-pads","text":"When two pads are mounted on the same stand, hitting one pad may trigger the sound from another pad unintentionally. (This is called crosstalk ). Eliminate this by adjusting Xtalk Cancel on the pad that is sounding inadvertently. In some cases, you can prevent crosstalk between two pads by increasing the distance between them. Crosstalk Example: If you hit the snare pad and the tom 1 also sounds Set the snare and tom 1 to the same XTALK GROUP. Raise the \u201cXTALK CANCEL\u201d for the pad being used for the tom 1. The tom 1 pad will be less prone to receive crosstalk from other pads. With a setting \u201cOFF,\u201d crosstalk prevention will not work. If the value is set too high, and two pads are played simultaneously, the one that is struck less forcefully may not sound. Be careful and set this parameter to the minimum value required to prevent crosstalk.","title":"XTALK (Eliminate Crosstalk Between Pads)"},{"location":"en/roland/trigger_settings/#advance-advanced-trigger-parameters","text":"","title":"ADVANCE (Advanced Trigger Parameters)"},{"location":"en/roland/trigger_settings/#scan-time-trigger-signal-detection-time-0-40-ms","text":"Specifies the detection time for the trigger signal. Since the rise time of the trigger signal waveform may differ slightly depending on the characteristics of each pad or acoustic drum trigger (drum pickup), you may notice that identical hits (velocity) may produce sound at different volumes. If this occurs, you can adjust the \u201cScan Time\u201d so that your way of playing can be detected more precisely. While repeatedly hitting the pad at a constant force, gradually raise the Scan Time value from 0 msec, until the resulting volume stabilizes at the loudest level. At this setting, try both soft and loud strikes, and make sure that the volume changes appropriately. As the value is set higher, the time it takes for the sound to be played increases. Set this to the lowest value possible.","title":"Scan Time (Trigger Signal Detection Time, 0 - 4.0 ms)"},{"location":"en/roland/trigger_settings/#retrigger-cancel-detecting-trigger-signal-attenuation-1-16","text":"This setting prevents spurious re-triggering. Important if you are using acoustic drum triggers. Such triggers can produce altered waveforms, which may also cause inadvertent sounding at Point A in the following figure ( Retrigger ). This occurs in particular at the decaying edge of the waveform. Retrigger Cancel detects such distortion in and prevents retriggering from occurring. While repeatedly striking the pad, raise the \u201cRetrig Cancel\u201d value until retriggering no longer occurs. Although setting this to a high value prevents retriggering, it then becomes easy for sounds to be omitted when the drums played fast (roll etc.). Set this to the lowest value possible while still ensuring that there is no retriggering. You can also eliminate this problem of retriggering with the Mask Time setting. Mask Time does not detect trigger signals if they occur within the specified amount of time after the previous trigger signal was received. Retrigger Cancel detects the attenuation of the trigger signal level, and triggers the sound after internally determining which trigger signals were actually generated when the head was struck, while weeding out the other false trigger signals that need not trigger a sound.","title":"Retrigger Cancel (Detecting Trigger Signal Attenuation, 1 - 16)"},{"location":"en/roland/trigger_settings/#mask-time-double-triggering-prevention-0-64-ms","text":"This setting prevents double triggering. When playing a kick trigger the beater can bounce back and hit the head a second time immediately after the intended note\u2014with acoustic drums sometimes the beater stays against the head\u2014this causes a single hit to \u201cdouble trigger\u201d (two sounds instead of one). The Mask Time setting helps to prevent this. Once a pad has been hit, any additional trigger signals occurring within the specified \u201cMask Time\u201d (0\u201364msec) will be ignored. Adjust the \u201cMask Time\u201d value while playing the pad. When using a kick trigger, try to let the beater bounce back and hit the head very quickly, then raise the \u201cMask Time\u201d value until there are no more sounds made by the beater rebound. When set to a high value, it will be difficult to play very quickly. Set this to as low a value as you can. If two or more sounds are being produced when you strike the head just once, then adjust Retrig Cancel.","title":"Mask Time (Double Triggering Prevention, 0 - 64 ms)"},{"location":"en/roland/trigger_settings/#rim-gain-rimedge-dynamic-response-0-32","text":"When a PD-125/120/105/85/80R, PD-9/8/7, CY series pad, VH-12/11, or RT-5S (trigger) is connected, you can adjust the relation between your playing velocity (force) on the rim/edge and the resulting volume level. Higher value allows the rim/edge to produce a loud volume even when played softly. Lower value will keep the rim/edge producing a low volume even when played forcefully.","title":"Rim Gain (Rim/Edge Dynamic Response, 0 \u2013 3.2)"},{"location":"en/roland/trigger_settings/#rim-shot-adjust-rim-shots-response-0-80","text":"When a PD-125/120/105/85/80R or RT-5S (trigger) is connected, you can adjust the sensitivity of the rim response. There are some cases that you have a rim sound unexpectedly when you hit the head strongly. You can improve this situation with decreasing the value of \u201cRimShot Adjust.\u201d When you set the value too small, it might be difficult to play the rim sound.","title":"Rim Shot Adjust (Rim Shots Response, 0 \u2013 8.0)"},{"location":"en/roland/trigger_settings/#xstick-thrshld-cross-stick-threshold-0-127","text":"When a PD-125/120/105/85/80R or RT-5S (trigger) is connected, you can determine the \u201ccross over point\u201d between the cross stick and a rim shot sounds. Setting this to a higher value makes it easier to get cross stick sounds. When set to \u201c0,\u201d playing a cross stick produces the open rim shot sound. Increasing the value excessively may cause the cross stick to sound as well when the open rim shot is played.","title":"XStick Thrshld (Cross Stick Threshold, 0 \u2013 127)"},{"location":"en/roland/vh11/","text":"20000 \u03a9 -> 13000 \u03a9 - Fully open sound 13000 \u03a9 -> 5000 \u03a9 - Half open sound 5000 \u03a9 -> 2500 \u03a9 - Half closed sound 2500 \u03a9 -> 50 \u03a9 - Fully closed sound Source: VDrums Forum","title":"VH-11 Resistance Values"},{"location":"en/samplerbox/build/","text":"Schematics BILL OF MATERIALS Qty Descr. Cod. 1 Raspberry Pi 2 1 SparkFun 7-Segment Serial Display Red COM-11441 1 Audio card dongle USB DAC PCM2704 1 PCB SD card reader RTS5159 1 Sparkfun microUSB breakout BOB-12035 1 3.5mm stereo jack socket 1 USB A connector (for PCB) 2 Digitast switch 1 MIDI socket 1 veroboard / perfboard 16 female-female Dupont cable 1 36 pin header 1 220\u03a9 resistor 1 10 K\u03a9 resistor 1 1 K\u03a9 resistor 1 1N4148 diode 1 6N138 optoisolator","title":"SamplerBox - Build the electronic parts"},{"location":"en/samplerbox/build/#schematics","text":"","title":"Schematics"},{"location":"en/samplerbox/build/#bill-of-materials","text":"Qty Descr. Cod. 1 Raspberry Pi 2 1 SparkFun 7-Segment Serial Display Red COM-11441 1 Audio card dongle USB DAC PCM2704 1 PCB SD card reader RTS5159 1 Sparkfun microUSB breakout BOB-12035 1 3.5mm stereo jack socket 1 USB A connector (for PCB) 2 Digitast switch 1 MIDI socket 1 veroboard / perfboard 16 female-female Dupont cable 1 36 pin header 1 220\u03a9 resistor 1 10 K\u03a9 resistor 1 1 K\u03a9 resistor 1 1N4148 diode 1 6N138 optoisolator","title":"BILL OF MATERIALS"},{"location":"en/samplerbox/faq/","text":"1. Q: What is SamplerBox, and why this project? A: SamplerBox is an electronic musical instrument. Drop audio samples onto it, hook up a MIDI keyboard, and you'll be able to play with realistic piano, organ, drums, etc. sounds! As strange as it may sound, if you wanted to add great piano sound to your MIDI keyboard or synthesizer, there was previously no hardware solution except using a computer (ok it works, but sometimes you don't feel like using a computer to do music) or buying an expensive sampler / expander. Now SamplerBox provides a sub-99\u20ac solution! 2. Q: What kind of MIDI keyboads can I connect to SamplerBox? A: There is no limitation about MIDI keyboards. Both USB MIDI keyboards (with a USB plug) and MIDI (with a MIDI plug) are accepted. You can use small 25-keys keyboards, such as the Akai LPK25 we use in some videos ; you can use 49 keys MIDI keyboards, or even 61 keys or 88 keys if you want! 3. Q: Where can I find instrument sample-sets to use with SamplerBox? A: You can find some instruments here . But you can also do some sample-sets yourself in a few seconds only (no sample-set-making skills required)! See questions #5 and #6 . 4. Q: Is velocity sensitivity possible? A: Yes. See question #6 . 5. Q: How to create my own sample-set to use with SamplerBox? (easy) A: If your samples are numbered by their usual MIDI note like this: 36.wav, 37.wav, ..., you just need to put these files in a folder named like this: /1 Piano/ , /17 Trumpet/ , ..., i.e. a number + a white space + a name. The number will be the preset number. No sample-set definition file required in this simple case! 6. Q: How to create my own sample-set to use with SamplerBox? (advanced) Sometimes, a picture speaks more than words, so don't forget to look at this blog article before reading what follows. If your samples are not named like 36.wav, 37.wav, and/or you want advanced features like many velocity layers, you need to create a folder (as described before) and have a definition.txt file in it. Let's say your samples are: /1 PIANO/MyPiano_60_vel70.wav /1 PIANO/MyPiano_60_vel100.wav /1 PIANO/MyPiano_61_vel70.wav /1 PIANO/MyPiano_61_vel100.wav ... Then just create a file named /1 PIANO/definition.txt containing this single line: MyPiano_%midinote_vel%velocity.wav Then SamplerBox will automatically detect and assign all the .wav files to the right notes and velocity layers! It's magic! 7. Q: Is it possible to change the MIDI channel and load two patches at once? (Let\u2019s say bass samples on channel 1 and horn samples on channel 2?) A: Currently SamplerBox reads all incoming MIDI notes, regardless the MIDI channel. But MIDI channel handling could be easily added, if this feature is really requested. Loading two patches at once is currently unsupported. 8. Q: Where should I put the sample-sets? A: If you installed SamplerBox via the image file (RECOMMANDED INSTALL), you have to put the sample-sets on a USB-stick (or on a SD card in a USB SD card reader) that you will plug into the RaspberryPi. This USB-stick / SD card should contain folders containing your .WAV samples, like this: /0 Piano/ /1 Flute/ ... Why not using the RaspberryPi's built-in microSD card? Two reasons: Because SamplerBox is a box! The user doesn't normally have access to the internal microSD card. The internal microSD card is used for OS and software, not for user sample-sets! Because you want to be able to plug in / remove / plug another SD card into the SamplerBox live! This wouldn't be possible by using the internal microSD card. If you installed SamplerBox via the MANUAL INSTALL , you can change the config in one line to use whatever you want as the sample-set source directory. 9. Q: How to change the current preset? A: Most MIDI keyboards have buttons called PROGRAM + / PROGRAM - that will send ProgramChange MIDI messages. These MIDI messages are used to change SamplerBox's current preset. How to change the current preset if you don't have such buttons on your keyboard? Use SamplerBox's hardware buttons : it's exactly what they are made for! 10. Q: What audio formats are supported? A: SamplerBox uses standard WAV files, stereo or mono, 16 bits or 24 bits, at a sampling rate of 44.1 Khz. It doesn't support AIFF, MP3, OGG, FLAC, etc. files. 11. Q: Do I need a Raspberry Pi 2 or will it work as well with a Raspberry B / B+ ? A: It will work on a Raspberry Pi B / B+, but better performances / higher polyphony will be achieved with a Raspberry Pi 2. 12. Q: How to put the SamplerBox image file, on a microSD card? A: See instructions here . 13. Q: (For developers only) Why is the filesystem mounted as read-only by default, when I use the SamplerBox image file? A: In short, removing the power cord without doing halt on a normal read-write filesystem could cause filesystem corruption. So if we want everything to work well, there are two solutions: either we have a normal read-write filesystem, and then we need to use halt command to shutdown safely the SamplerBox (but this is impossible, as everything is embedded in a box, with no keyboard!), or we use a read-only filesystem, and we can safely shut down the SamplerBox ... by just removing the power cord or using an ON/OFF switch (like on every synthesizer, for instance)! We used this second solution. If you know a better solution (read-write filesystem + safe shutdown when we remove the power cord), please contact us. Please note that it's always possible to remount as read-write after boot by doing: mount -o remount,rw / 14. Q: What about looping? I have a sample of an organ which is 1 second long, what happens if I press the key for two seconds? A: You just need to save loop markers in the WAV files with your traditional sound editor (I recommand Sony Soundforge), and SamplerBox will recognize them and loop the sound! 15. Q: How to permanently change the sound volume? A: This will evolve and be simpler in the future. For now, run this: alsamixer && mount -o remount,rw / && alsactl store then select your soundcard with the key <F6> , change the volume, and exit with <ESC> . The sound volume will be permanently saved. 16. Q: The audio output quality is bad. Why, and how to solve it? A: This is a well-known problem: the Raspberry Pi has a very poor built-in soundcard, resulting in noisy and sometimes stuttering sound. The only solution for this is to use a DAC, such as this 6\u20ac DAC , which has a very good audio output. 17. Q: When I boot the Raspberry Pi with the SamplerBox image, the software doesn't start automatically. How to solve this? A: The SamplerBox image is designed to be ready-to-use. The SamplerBox software should start automatically on boot. If not, there's a configuration issue. Open /root/SamplerBox/samplerbox.py and try another value for AUDIO_DEVICE_ID , it should solve the issue (try with the value 0 for example). If not, come to the forum and give some details about your configuration! 18. Q: Do I really need to build the whole thing (electronic parts, etc.) to use SamplerBox? A: No, you don't need to. You can start with just a bare RaspberryPi and no electronic parts. Read more about it here . 19. Q: Why is it impossible to edit the samples directly on SamplerBox ? Why not add a screen, a graphical user interface and editing features on SamplerBox, like on an Akai MPC? A: This would be possible with some work, but it would become a new, different project. The philosophy of SamplerBox is a bit different than a \"DIY Akai MPC\". My initial goal for SamplerBox was to design what we could call a customizable expander . It's designed to be able to comfortably load 500MB sample-sets, like big beautiful Piano sample-sets, with many velocity layers, etc. Such sample-sets cannot really be created on the small screen of a sampler. In a word, to program such sample-sets, you need a computer anyway. The initial philosophy was: prepare the sample-sets on a computer, drop them on a SD-card, and then insert the SD-card in SamplerBox, and that's it! Instead of doing two things badly (playing samples + poor editing on a small screen, with no keyboard, no mouse, etc.), I prefer to focus on doing one thing well: to be able to load big nice sample-sets that you've prepared on computer.","title":"SamplerBox - FAQ"},{"location":"en/samplerbox/faq/#1-q-what-is-samplerbox-and-why-this-project","text":"A: SamplerBox is an electronic musical instrument. Drop audio samples onto it, hook up a MIDI keyboard, and you'll be able to play with realistic piano, organ, drums, etc. sounds! As strange as it may sound, if you wanted to add great piano sound to your MIDI keyboard or synthesizer, there was previously no hardware solution except using a computer (ok it works, but sometimes you don't feel like using a computer to do music) or buying an expensive sampler / expander. Now SamplerBox provides a sub-99\u20ac solution!","title":"1. Q: What is SamplerBox, and why this project?"},{"location":"en/samplerbox/faq/#2-q-what-kind-of-midi-keyboads-can-i-connect-to-samplerbox","text":"A: There is no limitation about MIDI keyboards. Both USB MIDI keyboards (with a USB plug) and MIDI (with a MIDI plug) are accepted. You can use small 25-keys keyboards, such as the Akai LPK25 we use in some videos ; you can use 49 keys MIDI keyboards, or even 61 keys or 88 keys if you want!","title":"2. Q: What kind of MIDI keyboads can I connect to SamplerBox?"},{"location":"en/samplerbox/faq/#3-q-where-can-i-find-instrument-sample-sets-to-use-with-samplerbox","text":"A: You can find some instruments here . But you can also do some sample-sets yourself in a few seconds only (no sample-set-making skills required)! See questions #5 and #6 .","title":"3. Q: Where can I find instrument sample-sets to use with SamplerBox?"},{"location":"en/samplerbox/faq/#4-q-is-velocity-sensitivity-possible","text":"A: Yes. See question #6 .","title":"4. Q: Is velocity sensitivity possible?"},{"location":"en/samplerbox/faq/#5-q-how-to-create-my-own-sample-set-to-use-with-samplerbox-easy","text":"A: If your samples are numbered by their usual MIDI note like this: 36.wav, 37.wav, ..., you just need to put these files in a folder named like this: /1 Piano/ , /17 Trumpet/ , ..., i.e. a number + a white space + a name. The number will be the preset number. No sample-set definition file required in this simple case!","title":"5. Q: How to create my own sample-set to use with SamplerBox? (easy)"},{"location":"en/samplerbox/faq/#6-q-how-to-create-my-own-sample-set-to-use-with-samplerbox-advanced","text":"Sometimes, a picture speaks more than words, so don't forget to look at this blog article before reading what follows. If your samples are not named like 36.wav, 37.wav, and/or you want advanced features like many velocity layers, you need to create a folder (as described before) and have a definition.txt file in it. Let's say your samples are: /1 PIANO/MyPiano_60_vel70.wav /1 PIANO/MyPiano_60_vel100.wav /1 PIANO/MyPiano_61_vel70.wav /1 PIANO/MyPiano_61_vel100.wav ... Then just create a file named /1 PIANO/definition.txt containing this single line: MyPiano_%midinote_vel%velocity.wav Then SamplerBox will automatically detect and assign all the .wav files to the right notes and velocity layers! It's magic!","title":"6. Q: How to create my own sample-set to use with SamplerBox? (advanced)"},{"location":"en/samplerbox/faq/#7-q-is-it-possible-to-change-the-midi-channel-and-load-two-patches-at-once-lets-say-bass-samples-on-channel-1-and-horn-samples-on-channel-2","text":"A: Currently SamplerBox reads all incoming MIDI notes, regardless the MIDI channel. But MIDI channel handling could be easily added, if this feature is really requested. Loading two patches at once is currently unsupported.","title":"7. Q: Is it possible to change the MIDI channel and load two patches at once? (Let\u2019s say bass samples on channel 1 and horn samples on channel 2?)"},{"location":"en/samplerbox/faq/#8-q-where-should-i-put-the-sample-sets","text":"A: If you installed SamplerBox via the image file (RECOMMANDED INSTALL), you have to put the sample-sets on a USB-stick (or on a SD card in a USB SD card reader) that you will plug into the RaspberryPi. This USB-stick / SD card should contain folders containing your .WAV samples, like this: /0 Piano/ /1 Flute/ ... Why not using the RaspberryPi's built-in microSD card? Two reasons: Because SamplerBox is a box! The user doesn't normally have access to the internal microSD card. The internal microSD card is used for OS and software, not for user sample-sets! Because you want to be able to plug in / remove / plug another SD card into the SamplerBox live! This wouldn't be possible by using the internal microSD card. If you installed SamplerBox via the MANUAL INSTALL , you can change the config in one line to use whatever you want as the sample-set source directory.","title":"8. Q: Where should I put the sample-sets?"},{"location":"en/samplerbox/faq/#9-q-how-to-change-the-current-preset","text":"A: Most MIDI keyboards have buttons called PROGRAM + / PROGRAM - that will send ProgramChange MIDI messages. These MIDI messages are used to change SamplerBox's current preset. How to change the current preset if you don't have such buttons on your keyboard? Use SamplerBox's hardware buttons : it's exactly what they are made for!","title":"9. Q: How to change the current preset?"},{"location":"en/samplerbox/faq/#10-q-what-audio-formats-are-supported","text":"A: SamplerBox uses standard WAV files, stereo or mono, 16 bits or 24 bits, at a sampling rate of 44.1 Khz. It doesn't support AIFF, MP3, OGG, FLAC, etc. files.","title":"10. Q: What audio formats are supported?"},{"location":"en/samplerbox/faq/#11-q-do-i-need-a-raspberry-pi-2-or-will-it-work-as-well-with-a-raspberry-b-b","text":"A: It will work on a Raspberry Pi B / B+, but better performances / higher polyphony will be achieved with a Raspberry Pi 2.","title":"11. Q: Do I need a Raspberry Pi 2 or will it work as well with a Raspberry B / B+ ?"},{"location":"en/samplerbox/faq/#12-q-how-to-put-the-samplerbox-image-file-on-a-microsd-card","text":"A: See instructions here .","title":"12. Q: How to put the SamplerBox image file, on a microSD card?"},{"location":"en/samplerbox/faq/#13-q-for-developers-only-why-is-the-filesystem-mounted-as-read-only-by-default-when-i-use-the-samplerbox-image-file","text":"A: In short, removing the power cord without doing halt on a normal read-write filesystem could cause filesystem corruption. So if we want everything to work well, there are two solutions: either we have a normal read-write filesystem, and then we need to use halt command to shutdown safely the SamplerBox (but this is impossible, as everything is embedded in a box, with no keyboard!), or we use a read-only filesystem, and we can safely shut down the SamplerBox ... by just removing the power cord or using an ON/OFF switch (like on every synthesizer, for instance)! We used this second solution. If you know a better solution (read-write filesystem + safe shutdown when we remove the power cord), please contact us. Please note that it's always possible to remount as read-write after boot by doing: mount -o remount,rw /","title":"13. Q: (For developers only) Why is the filesystem mounted as read-only by default, when I use the SamplerBox image file?"},{"location":"en/samplerbox/faq/#14-q-what-about-looping-i-have-a-sample-of-an-organ-which-is-1-second-long-what-happens-if-i-press-the-key-for-two-seconds","text":"A: You just need to save loop markers in the WAV files with your traditional sound editor (I recommand Sony Soundforge), and SamplerBox will recognize them and loop the sound!","title":"14. Q: What about looping? I have a sample of an organ which is 1 second long, what happens if I press the key for two seconds?"},{"location":"en/samplerbox/faq/#15-q-how-to-permanently-change-the-sound-volume","text":"A: This will evolve and be simpler in the future. For now, run this: alsamixer && mount -o remount,rw / && alsactl store then select your soundcard with the key <F6> , change the volume, and exit with <ESC> . The sound volume will be permanently saved.","title":"15. Q: How to permanently change the sound volume?"},{"location":"en/samplerbox/faq/#16-q-the-audio-output-quality-is-bad-why-and-how-to-solve-it","text":"A: This is a well-known problem: the Raspberry Pi has a very poor built-in soundcard, resulting in noisy and sometimes stuttering sound. The only solution for this is to use a DAC, such as this 6\u20ac DAC , which has a very good audio output.","title":"16. Q: The audio output quality is bad. Why, and how to solve it?"},{"location":"en/samplerbox/faq/#17-q-when-i-boot-the-raspberry-pi-with-the-samplerbox-image-the-software-doesnt-start-automatically-how-to-solve-this","text":"A: The SamplerBox image is designed to be ready-to-use. The SamplerBox software should start automatically on boot. If not, there's a configuration issue. Open /root/SamplerBox/samplerbox.py and try another value for AUDIO_DEVICE_ID , it should solve the issue (try with the value 0 for example). If not, come to the forum and give some details about your configuration!","title":"17. Q: When I boot the Raspberry Pi with the SamplerBox image, the software doesn't start automatically. How to solve this?"},{"location":"en/samplerbox/faq/#18-q-do-i-really-need-to-build-the-whole-thing-electronic-parts-etc-to-use-samplerbox","text":"A: No, you don't need to. You can start with just a bare RaspberryPi and no electronic parts. Read more about it here .","title":"18. Q: Do I really need to build the whole thing (electronic parts, etc.) to use SamplerBox?"},{"location":"en/samplerbox/faq/#19-q-why-is-it-impossible-to-edit-the-samples-directly-on-samplerbox-why-not-add-a-screen-a-graphical-user-interface-and-editing-features-on-samplerbox-like-on-an-akai-mpc","text":"A: This would be possible with some work, but it would become a new, different project. The philosophy of SamplerBox is a bit different than a \"DIY Akai MPC\". My initial goal for SamplerBox was to design what we could call a customizable expander . It's designed to be able to comfortably load 500MB sample-sets, like big beautiful Piano sample-sets, with many velocity layers, etc. Such sample-sets cannot really be created on the small screen of a sampler. In a word, to program such sample-sets, you need a computer anyway. The initial philosophy was: prepare the sample-sets on a computer, drop them on a SD-card, and then insert the SD-card in SamplerBox, and that's it! Instead of doing two things badly (playing samples + poor editing on a small screen, with no keyboard, no mouse, etc.), I prefer to focus on doing one thing well: to be able to load big nice sample-sets that you've prepared on computer.","title":"19. Q: Why is it impossible to edit the samples directly on SamplerBox ? Why not add a screen, a graphical user interface and editing features on SamplerBox, like on an Akai MPC?"},{"location":"en/samplerbox/home/","text":"Features Drop'n'play sampler: drop .WAV samples on the SD card, and play! Open source / open hardware Raspberry Pi computer inside, download the ready-to-use ISO image! Cheap: < 99\u20ac to build Boot time: 8 seconds Polyphony: more than 128 voices Low latency Memory: can load sample-sets up to 1 GB Look at the blog to see the latest prototypes! Here is what this project is about: Playing piano with SamplerBox:","title":"SamplerBox - Home"},{"location":"en/samplerbox/home/#features","text":"Drop'n'play sampler: drop .WAV samples on the SD card, and play! Open source / open hardware Raspberry Pi computer inside, download the ready-to-use ISO image! Cheap: < 99\u20ac to build Boot time: 8 seconds Polyphony: more than 128 voices Low latency Memory: can load sample-sets up to 1 GB Look at the blog to see the latest prototypes! Here is what this project is about: Playing piano with SamplerBox:","title":"Features"},{"location":"en/search/","text":"{% include search.html %}","title":"Search"},{"location":"en/sfz/drumkits/","text":"Drumkits Download 60s Rogers Pop Kit AVL Drumkits AVL Drumkits LV2 Plugin Big Mono Free Drum Samples for Kontakt Colombo Acoustic Drum Kit G&S Custom Work Drum Kits for Kontakt Jazz Funk Drum Library Jazz Funk Drum Library SFZ mapping Kingston Drums Pettinhouse Drum Kits Salamander Drumkit Salamander Drumkit Download Salamander Drumkit Kick Fix Sennheiser DrumMic\u2019a! for Kontakt SM Drums for Sforzando","title":"Drumkits Download"},{"location":"en/sfz/drumkits/#drumkits-download","text":"60s Rogers Pop Kit AVL Drumkits AVL Drumkits LV2 Plugin Big Mono Free Drum Samples for Kontakt Colombo Acoustic Drum Kit G&S Custom Work Drum Kits for Kontakt Jazz Funk Drum Library Jazz Funk Drum Library SFZ mapping Kingston Drums Pettinhouse Drum Kits Salamander Drumkit Salamander Drumkit Download Salamander Drumkit Kick Fix Sennheiser DrumMic\u2019a! for Kontakt SM Drums for Sforzando","title":"Drumkits Download"},{"location":"en/utilities/","text":"App Description Source Synthclone kontakt nki to sfz conversion https://www.kvraudio.com/forum/viewtopic.php?t=368923","title":"Utilities"},{"location":"it/","text":"Qui troverete alcuni spunti per costruire la vostra batteria elettronica. Molti dei pad che si possono trovare nel mercato non rendono lo stesso feeling di una batteria acustica, quindi possiamo convertirne una in elettronica sostituendo le pelli originali con delle pelli mesh e aggiungendo dei sensori piezo elettrici da collegare al modulo sonoro.","title":"Benvenuti"},{"location":"it/diy/sensor_cushion/","text":"Foto 1: Lo strumento \u00e8 composto da 2 lamine di alluminio da 38 x 3 mm avvitati su un pezzo di listello di legno da 57 x 35 mm. Per bloccare i coni viene utilizzato un perno a 'T' da 45 mm, meglio se da 50. Foto 2: Per poter inserire il perno le lamine vengono forate utilizzando una punta di piccolo diametro (1 mm), al centro di quella inferiore (19 mm per lato) e a 3 mm da un lato di quella superiore. Le lamine devono essere allineate al pezzo di listello su entrambi i lati. Le due linee sulla lamina inferiore vengono utilizzate come guide dove posizionare la base del materiale da tagliare. Lo strumento verr\u00e0 fissato sul banco da lavoro. Foto 3: Qui viene utilizzato un profilo di Supersoft Poron dello spessore di 9,5 mm (3/8\") con superficie adesiva inserito tra altri due da 12,7 mm (1/2\"). Le misure di sinistra si riferiscono alla misura massima di ciascun livello, rispettivamente 38, 31,8 e 20 mm, e quelle di destra dei relativi spessori. Si potrebbero tagliare di forma circolare ma in questo modo \u00e8 pi\u00f9 semplice anche se crea pi\u00f9 scarto. Foto 4: I pezzi sono pronti e posizionati. Il perno viene inserito dalla base verso l'alto, cercando di mantenerlo in linea con il foro superiore, sporgendo sopra quanto basta per rimanere fermo in posizione durante il taglio. Premendo lo strato superiore del materiale per far sporgere la punta del perno ci si pu\u00f2 aiutare per farlo coincidere ed inserire nel foro superiore. Foto 5: Usando un coltello elettrico (si pu\u00f2 usare un seghetto manuale o un coltello a denti fini) si inizia a tagliare tenendo la lama appoggiata ai bordi delle lamine di alluminio. A questo punto si ruota delicatamente il cono verso la lama, facendo attenzione a non comprimerlo per evitare un taglio errato. Terminato il taglio, si pu\u00f2 rifinire il cono con un foglio di carta abrasiva con grana da 50. Sulla base del cono si pu\u00f2 usare un cutter per creare l'incavo per il passaggio dei fili, altrimenti si pu\u00f2 usare la punta di un saldatore a stagno. La lamina superiore pu\u00f2 essere rifilata rispettando l'angolazione del taglio per permettere al coltello di appoggiarsi con pi\u00f9 precisione, risultando in una misura precisa anche per la superficie superiore del cono. Lo strumento nelle foto \u00e8 stato realizzato per persone mancine, quindi per i destri potrebbe essere necessaria una diversa costruzione.","title":"Easy to make cone jig"},{"location":"it/news/","text":"{{ blog_content }}","title":"Ultime Novit\u00e0"},{"location":"it/news/posts/2017-07-02-nuovo-sito-avviato/","text":"Siamo orgogliosi di annunciare il nuovo sito web di E-Drums Project! Il design responsive rende il sito accessibile da qualsiasi dispositivo. Utilizzo di Bootstrap per una semplice personalizzazione grafica. Creato con Jekyll . Possibilit\u00e0 di scrivere dei commenti nelle notizie: facci sapere cosa ne pensi! La maggior parte dei contenuti \u00e8 scritta in Markdown . Gli aggiornamenti possono essere inviati direttamente su GitHub .","title":"Nuovo Sito Avviato"},{"location":"it/roland/adding_pads/","text":"Istruzioni Semplificate per espandere la TD-20 (o TD-12) con un trigger esterno Assicurarsi che i pad connessi al trigger esterno siano impostati sul canale 11. Sul trigger esterno, impostare le note della pelle e rim in modo logico e semplice da ricordare (es.: head:40 e rim:41). Fare questo per tutti i pad necessari (impostando ovviamente note diverse ciascuno). Premere \"Pattern\" sul modulo e girare la rotellina finch\u00e9 non appare \"Part\" sopra il pulsante F2 (se non c'\u00e9 gi\u00e0 ovviamente). Premere F2 (Part), quindi F3 (Perc). Selezionare il kit desiderato e quindi premere F5 per la modifica. Ora vi trovate nella schermata \"Percussion Set Edit\". Premere F2 (edit). Andare su \"perc note\" e selezionare la nota assegnata in precedenza per la pelle o il rim (a seconda di quello che volete usare). Sar\u00e0 necessario fare questo per ciascuna pelle e rim di ciascun pad da usare. Una volta terminato potrete premere List nella schermata Percussion set edit per scegliere quale strumento volete assegnare alla pelle o rim del pad. Inoltre \u00e8 possibile cambiare le impostazioni del volume, panning, pitch, decay, riverbero, chorus e CC di ciascun strumento. Ora tutte le modifiche per i pad collegati al vostro trigger esterno sono impostate nel vostro modulo (tranne le impostazioni dei trigger quali sensibilit\u00e0, threshold ecc.). Origine: VDrums.com Forum","title":"Aggiungere pad alla Roland TD-12 e TD-20"},{"location":"it/roland/adding_pads/#istruzioni-semplificate-per-espandere-la-td-20-o-td-12-con-un-trigger-esterno","text":"Assicurarsi che i pad connessi al trigger esterno siano impostati sul canale 11. Sul trigger esterno, impostare le note della pelle e rim in modo logico e semplice da ricordare (es.: head:40 e rim:41). Fare questo per tutti i pad necessari (impostando ovviamente note diverse ciascuno). Premere \"Pattern\" sul modulo e girare la rotellina finch\u00e9 non appare \"Part\" sopra il pulsante F2 (se non c'\u00e9 gi\u00e0 ovviamente). Premere F2 (Part), quindi F3 (Perc). Selezionare il kit desiderato e quindi premere F5 per la modifica. Ora vi trovate nella schermata \"Percussion Set Edit\". Premere F2 (edit). Andare su \"perc note\" e selezionare la nota assegnata in precedenza per la pelle o il rim (a seconda di quello che volete usare). Sar\u00e0 necessario fare questo per ciascuna pelle e rim di ciascun pad da usare. Una volta terminato potrete premere List nella schermata Percussion set edit per scegliere quale strumento volete assegnare alla pelle o rim del pad. Inoltre \u00e8 possibile cambiare le impostazioni del volume, panning, pitch, decay, riverbero, chorus e CC di ciascun strumento. Ora tutte le modifiche per i pad collegati al vostro trigger esterno sono impostate nel vostro modulo (tranne le impostazioni dei trigger quali sensibilit\u00e0, threshold ecc.). Origine: VDrums.com Forum","title":"Istruzioni Semplificate per espandere la TD-20 (o TD-12) con un trigger esterno"},{"location":"it/roland/dynamic/","text":"Azzerare tutti i cursori del volume per poter alzare o abbassare. Impostare tutti i volumi dei pad e rim nel mixer del modulo a 80. Impostare il volume del kit a 127 Impostare il compressore, EQ, e Ambience a spento. Posizionarsi nel menu trigger e impostare la sensibilit\u00e0 del rim e della pelle in modo da raggiungere il picco massimo nel meter con i colpi pi\u00f9 forti. Impostare il threshold per i colpi pi\u00f9 leggeri. A questo punto dovresti avere ottenuto il massimo intervallo di dinamica per il tuo kit. Se in precedenza avevi problemi di effetto mitragliatrice, dovrebbero essere stati risolti. Impostare le curve di ciascun pad in base al vostro stile. Qui \u00e8 dove si sentiranno dei cambiamenti nella dinamica di esecuzione. Linear lo dice la parola stessa... lineare. EXP1 e 2 rimuovono le dinamiche medie rendendo pi\u00f9 leggeri anche i colpi medi e forti. LOG1 e 2 alzano le dinamiche medie rendendole pi\u00f9 forti. Spline filtra le dinamiche medie accentuando quelle forti e leggere. Estremo ma efficace soprattutto con i tom e sull'arco del ride. Infine LOUD1 e 2. Questi rimuovono le dinamiche basse alzando il volume nei colpi leggeri e medi. Ritornare a impostare ciascun volume dei pad sul mixer in modo tale da ottenere i volumi corretti per tutte le percussioni. Infine riattivare il compressore, EQ e ambiance. Origine: VDrums.com forum","title":"Dinamica"},{"location":"it/roland/trigger_settings/","text":"BASIC Sensibilit\u00e0 del Pad (1 - 32) Potete regolare la sensibilit\u00e0 dei pad a seconda del vostro stile esecutivo personale. Questo vi permette di ottenere un controllo pi\u00f9 dinamico del volume del suono, a seconda della forza con cui suonate. Una sensibilit\u00e0 maggiore vi permette di produrre un volume pi\u00f9 intenso anche quando suonate piano. Una sensibilit\u00e0 inferiore fa si che il pad produca un volume pi\u00f9 basso anche quando suonate con forza. Threshold (Livello minimo del pad, 0 - 31) Questa impostazione permette di ricevere il segnale di trigger solo quando il colpo supera un livello di forza (velocity) determinato. Questo pu\u00f2 essere utilizzato per evitare che un pad suoni a causa delle vibrazioni degli altri pad. Nell\u2019esempio sotto, B suona, ma A e C non suonano. Con valori maggiori, non si produce alcun suono quando suonate il pad delicatamente. Alzate gradualmente il valore di \u201cThreshold\u201d mentre suonate il pad. Controllate e regolate conformemente. Ripetere il processo sino ad ottenere l\u2019impostazione pi\u00f9 adatta al vostro stile. Velocity Curve (Come la Dinamica dell\u2019Esecuzione Cambia il Volume) Questa impostazione vi permette di controllare la relazione tra la dinamica dell\u2019esecuzione (forza dei colpi) e i cambiamenti di volume. Regolate questa curva sino a quando la risposta non risulta il pi\u00f9 naturale possibile. LINEAR L\u2019impostazione standard. Produce la corrispondenza pi\u00f9 naturale tra dinamica e cambiamenti di volume. EXP1, EXP2 Rispetto a LINEAR, dinamiche pi\u00f9 intense producono un maggior cambiamento. LOG1, LOG2 Rispetto a LINEAR, dinamiche meno intense producono un maggior cambiamento. SPLINE Avvengono cambiamenti estremi in risposta alle dinamiche dell\u2019esecuzione. LOUD1, LOUD2 Risposte alla dinamica molto ridotte, che rendono semplice mantenere livelli di volume intensi. Se usate trigger per tamburi acustici, queste impostazioni vi aiutano a mantenere livelli stabili. XTALK (Eliminare le Interferenze tra i Pad) Quando due pad sono montati sullo stesso supporto, colpendo un pad si potrebbe innescare il suono dell\u2019altro pad in modo involontario. (Questo prende il nome di diafonia ). Questo problema pu\u00f2 essere eliminato regolando il parametro Xtalk Cancel del pad che suona inavvertitamente. In certi casi, potete eliminare le interferenze tra i due pad aumentando la distanza tra loro. Esempio di interferenza: colpite il pad del rullante e suona anche il tom 1 Impostate il rullante e il tom 1 sullo stesso XTALK GROUP. Alzate l\u2019\u201cXTALK CANCEL\u201d del pad che viene usato per il tom 1. Il pad del tom 1 ora ha meno possibilit\u00e0 di ricevere le interferenze dagli altri pad. Con l\u2019impostazione \u201cOFF,\u201d la prevenzione delle interferenze non funziona. Se il valore impostato \u00e8 troppo elevato, e i due pad vengono suonati simultaneamente, quello che viene colpito con minor forza potrebbe non suonare. Fate attenzione e impostate questo parametro sul valore minimo necessario per evitare le interferenze. ADVANCE (Parametri Trigger Avanzati) Scan Time (Tempo di Rilevamento del Segnale di Trigger, 0 - 4.0 ms) Poich\u00e9 il tempo di salita della forma d\u2019onda del segnale di trigger pu\u00f2 variare leggermente a seconda delle caratteristiche di ogni pad o trigger per tamburi acustici (drum pickup), potreste notare che colpi identici (per intensit\u00e0) possono produrre suoni a volumi differenti. In questi casi, potete regolare lo \u201cScan Time\u201d cos\u00ec che il modo in cui suonate possa essere rilevato in modo pi\u00f9 preciso. Colpendo ripetutamente il pad con una forza costante, alzate gradualmente il valore dello Scan Time da 0 msec, sino a quando il volume risultante non si stabilizza al livello pi\u00f9 intenso. Con questa impostazione, provate sia colpi deboli che forti, e controllate che il volume cambi in modo appropriato. Alzando il valore, aumenta il tempo necessario per produrre il suono. Perci\u00f2 impostate il valore pi\u00f9 basso possibile. Retrigger Cancel (Attenuazione del rilevamento del segnale di trigger, 1 - 16) Importante se state utilizzando trigger per tamburi acustici. Tali trigger possono produrre forme d\u2019onda alterate, che possono produrre anche suoni indesiderati nel punto A della seguente figura ( Retrigger ). Questo avviene in particolare nella fase di decadimento della forma d\u2019onda. Retrigger Cancel rileva tale distorsione e impedisce il verificarsi del reinnesco. Colpendo ripetutamente il pad, alzate il valore di \u201cRetrig Cancel\u201d sino a che non si verificano pi\u00f9 reinneschi. Bench\u00e9 impostando questo parametro ad un valore l\u2019alto si impediscano i retrigger, \u00e8 pi\u00f9 facile che i suoni vengano omessi quando il tamburo viene suonato velocemente (rullate, etc.). Impostatelo sul valore minimo possibile che consente di impedire i reinneschi indesiderati. Potete anche eliminare questo problema di retrigger con l\u2019impostazione Mask Time. Mask Time non rileva i segnali di trigger che avvengono entro la quantit\u00e0 di tempo specificata dopo aver ricevuto il segnale di innesco precedente. Retrigger Cancel rileva l\u2019attenuazione del livello del segnale di trigger, e innesca il suono dopo aver determinato internamente quali segnali di trigger sono stati effettivamente generati quando \u00e8 stata colpita la pelle, eliminando gli altri segnali di trigger falsi che non devono innescare il suono. Mask Time (Prevenzione dei Doppi Inneschi, 0 - 64 ms) Quando suonate un kick per la cassa il battente pu\u00f2 rimbalzare e colpire la pelle una seconda volta immediatamente dopo la nota desiderata \u2014 con i tamburi acustici certe volte il battente resta contro la pelle \u2014 questo fa si che un singolo colpo provochi un \u201cdoppio trigger\u201d (due suoni invece di uno). L\u2019impostazione Mask Time vi aiuta a evitare questo problema. Dopo che un pad \u00e8 stato colpito, qualsiasi segnale di trigger aggiuntivo che avviene all\u2019interno del \u201cMask Time\u201d (0\u201364 msec) specificato viene ignorato. Regolate il valore del \u201cMask Time\u201d mentre suonate il pad. Quando suonate un kick trigger, provate a lasciar rimbalzare il battente cos\u00ec che colpisca la pelle molto velocemente, poi alzate il valore del \u201cMask Time\u201d sino a quando non vi sono pi\u00f9 suoni provocati dal rimbalzo del battente. Con un valore elevato, diventa difficile suonare molto velocemente. Impostate il valore pi\u00f9 basso possibile. Se si generano due o pi\u00f9 suoni quando colpite la pelle solo una volta, allora regolate Retrig Cancel. Rim Gain (Risposta dinamica Rim/Edge, 0 \u2013 3.2) Quando \u00e8 collegato un pad PD-125/120/105/85/80R, PD-9/8/7, serie CY, VH-12/11, o RT-5S (trigger), potete regolare la relazione tra la dinamica della vostra esecuzione (forza) sul cerchio/bordo e il livello di volume prodotto. Valori pi\u00f9 elevati permettono al cerchio/bordo di produrre un volume intenso anche quando suonate piano. Valori bassi fanno si che il cerchio/bordo produca un volume basso anche quando viene suonato con forza. Rim Shot Adjust (Risposta ai Rim Shot, 0 \u2013 8.0) Quando \u00e8 collegato un PD-125/120/105/85/80R o RT-5S (trigger), potete regolare la sensibilit\u00e0 della risposta del cerchio. Vi sono casi in cui suona anche il cerchio inaspettatamente quando colpite con forza la pelle. Potete migliorare la situazione riducendo il valore di \u201cRimShot Adjust.\u201d Quando impostate un valore troppo basso, pu\u00f2 essere difficile produrre il suono del cerchio. XStick Thrshld (Cross Stick Threshold, 0 \u2013 127) Quando \u00e8 collegato un PD-125/120/105/85/80R o RT-5S (trigger), potete determinare il \u201cpunto di incrocio\u201d tra i suoni del cross stick e il rim shot. Impostando questo parametro ad un valore elevato \u00e8 pi\u00f9 facile ottenere i suoni del cross stick. Quando \u00e8 impostato a \u201c0,\u201d suonando un cross stick si produce il suono dell\u2019open rim shot. Alzando eccessivamente il valore, potrebbe suonare il cross stick anche quando eseguite un open rim shot.","title":"Impostazioni dei Trigger"},{"location":"it/roland/trigger_settings/#basic","text":"","title":"BASIC"},{"location":"it/roland/trigger_settings/#sensibilita-del-pad-1-32","text":"Potete regolare la sensibilit\u00e0 dei pad a seconda del vostro stile esecutivo personale. Questo vi permette di ottenere un controllo pi\u00f9 dinamico del volume del suono, a seconda della forza con cui suonate. Una sensibilit\u00e0 maggiore vi permette di produrre un volume pi\u00f9 intenso anche quando suonate piano. Una sensibilit\u00e0 inferiore fa si che il pad produca un volume pi\u00f9 basso anche quando suonate con forza.","title":"Sensibilit\u00e0 del Pad (1 - 32)"},{"location":"it/roland/trigger_settings/#threshold-livello-minimo-del-pad-0-31","text":"Questa impostazione permette di ricevere il segnale di trigger solo quando il colpo supera un livello di forza (velocity) determinato. Questo pu\u00f2 essere utilizzato per evitare che un pad suoni a causa delle vibrazioni degli altri pad. Nell\u2019esempio sotto, B suona, ma A e C non suonano. Con valori maggiori, non si produce alcun suono quando suonate il pad delicatamente. Alzate gradualmente il valore di \u201cThreshold\u201d mentre suonate il pad. Controllate e regolate conformemente. Ripetere il processo sino ad ottenere l\u2019impostazione pi\u00f9 adatta al vostro stile.","title":"Threshold (Livello minimo del pad, 0 - 31)"},{"location":"it/roland/trigger_settings/#velocity-curve-come-la-dinamica-dellesecuzione-cambia-il-volume","text":"Questa impostazione vi permette di controllare la relazione tra la dinamica dell\u2019esecuzione (forza dei colpi) e i cambiamenti di volume. Regolate questa curva sino a quando la risposta non risulta il pi\u00f9 naturale possibile. LINEAR L\u2019impostazione standard. Produce la corrispondenza pi\u00f9 naturale tra dinamica e cambiamenti di volume. EXP1, EXP2 Rispetto a LINEAR, dinamiche pi\u00f9 intense producono un maggior cambiamento. LOG1, LOG2 Rispetto a LINEAR, dinamiche meno intense producono un maggior cambiamento. SPLINE Avvengono cambiamenti estremi in risposta alle dinamiche dell\u2019esecuzione. LOUD1, LOUD2 Risposte alla dinamica molto ridotte, che rendono semplice mantenere livelli di volume intensi. Se usate trigger per tamburi acustici, queste impostazioni vi aiutano a mantenere livelli stabili.","title":"Velocity Curve (Come la Dinamica dell\u2019Esecuzione Cambia il Volume)"},{"location":"it/roland/trigger_settings/#xtalk-eliminare-le-interferenze-tra-i-pad","text":"Quando due pad sono montati sullo stesso supporto, colpendo un pad si potrebbe innescare il suono dell\u2019altro pad in modo involontario. (Questo prende il nome di diafonia ). Questo problema pu\u00f2 essere eliminato regolando il parametro Xtalk Cancel del pad che suona inavvertitamente. In certi casi, potete eliminare le interferenze tra i due pad aumentando la distanza tra loro. Esempio di interferenza: colpite il pad del rullante e suona anche il tom 1 Impostate il rullante e il tom 1 sullo stesso XTALK GROUP. Alzate l\u2019\u201cXTALK CANCEL\u201d del pad che viene usato per il tom 1. Il pad del tom 1 ora ha meno possibilit\u00e0 di ricevere le interferenze dagli altri pad. Con l\u2019impostazione \u201cOFF,\u201d la prevenzione delle interferenze non funziona. Se il valore impostato \u00e8 troppo elevato, e i due pad vengono suonati simultaneamente, quello che viene colpito con minor forza potrebbe non suonare. Fate attenzione e impostate questo parametro sul valore minimo necessario per evitare le interferenze.","title":"XTALK (Eliminare le Interferenze tra i Pad)"},{"location":"it/roland/trigger_settings/#advance-parametri-trigger-avanzati","text":"","title":"ADVANCE (Parametri Trigger Avanzati)"},{"location":"it/roland/trigger_settings/#scan-time-tempo-di-rilevamento-del-segnale-di-trigger-0-40-ms","text":"Poich\u00e9 il tempo di salita della forma d\u2019onda del segnale di trigger pu\u00f2 variare leggermente a seconda delle caratteristiche di ogni pad o trigger per tamburi acustici (drum pickup), potreste notare che colpi identici (per intensit\u00e0) possono produrre suoni a volumi differenti. In questi casi, potete regolare lo \u201cScan Time\u201d cos\u00ec che il modo in cui suonate possa essere rilevato in modo pi\u00f9 preciso. Colpendo ripetutamente il pad con una forza costante, alzate gradualmente il valore dello Scan Time da 0 msec, sino a quando il volume risultante non si stabilizza al livello pi\u00f9 intenso. Con questa impostazione, provate sia colpi deboli che forti, e controllate che il volume cambi in modo appropriato. Alzando il valore, aumenta il tempo necessario per produrre il suono. Perci\u00f2 impostate il valore pi\u00f9 basso possibile.","title":"Scan Time (Tempo di Rilevamento del Segnale di Trigger, 0 - 4.0 ms)"},{"location":"it/roland/trigger_settings/#retrigger-cancel-attenuazione-del-rilevamento-del-segnale-di-trigger-1-16","text":"Importante se state utilizzando trigger per tamburi acustici. Tali trigger possono produrre forme d\u2019onda alterate, che possono produrre anche suoni indesiderati nel punto A della seguente figura ( Retrigger ). Questo avviene in particolare nella fase di decadimento della forma d\u2019onda. Retrigger Cancel rileva tale distorsione e impedisce il verificarsi del reinnesco. Colpendo ripetutamente il pad, alzate il valore di \u201cRetrig Cancel\u201d sino a che non si verificano pi\u00f9 reinneschi. Bench\u00e9 impostando questo parametro ad un valore l\u2019alto si impediscano i retrigger, \u00e8 pi\u00f9 facile che i suoni vengano omessi quando il tamburo viene suonato velocemente (rullate, etc.). Impostatelo sul valore minimo possibile che consente di impedire i reinneschi indesiderati. Potete anche eliminare questo problema di retrigger con l\u2019impostazione Mask Time. Mask Time non rileva i segnali di trigger che avvengono entro la quantit\u00e0 di tempo specificata dopo aver ricevuto il segnale di innesco precedente. Retrigger Cancel rileva l\u2019attenuazione del livello del segnale di trigger, e innesca il suono dopo aver determinato internamente quali segnali di trigger sono stati effettivamente generati quando \u00e8 stata colpita la pelle, eliminando gli altri segnali di trigger falsi che non devono innescare il suono.","title":"Retrigger Cancel (Attenuazione del rilevamento del segnale di trigger, 1 - 16)"},{"location":"it/roland/trigger_settings/#mask-time-prevenzione-dei-doppi-inneschi-0-64-ms","text":"Quando suonate un kick per la cassa il battente pu\u00f2 rimbalzare e colpire la pelle una seconda volta immediatamente dopo la nota desiderata \u2014 con i tamburi acustici certe volte il battente resta contro la pelle \u2014 questo fa si che un singolo colpo provochi un \u201cdoppio trigger\u201d (due suoni invece di uno). L\u2019impostazione Mask Time vi aiuta a evitare questo problema. Dopo che un pad \u00e8 stato colpito, qualsiasi segnale di trigger aggiuntivo che avviene all\u2019interno del \u201cMask Time\u201d (0\u201364 msec) specificato viene ignorato. Regolate il valore del \u201cMask Time\u201d mentre suonate il pad. Quando suonate un kick trigger, provate a lasciar rimbalzare il battente cos\u00ec che colpisca la pelle molto velocemente, poi alzate il valore del \u201cMask Time\u201d sino a quando non vi sono pi\u00f9 suoni provocati dal rimbalzo del battente. Con un valore elevato, diventa difficile suonare molto velocemente. Impostate il valore pi\u00f9 basso possibile. Se si generano due o pi\u00f9 suoni quando colpite la pelle solo una volta, allora regolate Retrig Cancel.","title":"Mask Time (Prevenzione dei Doppi Inneschi, 0 - 64 ms)"},{"location":"it/roland/trigger_settings/#rim-gain-risposta-dinamica-rimedge-0-32","text":"Quando \u00e8 collegato un pad PD-125/120/105/85/80R, PD-9/8/7, serie CY, VH-12/11, o RT-5S (trigger), potete regolare la relazione tra la dinamica della vostra esecuzione (forza) sul cerchio/bordo e il livello di volume prodotto. Valori pi\u00f9 elevati permettono al cerchio/bordo di produrre un volume intenso anche quando suonate piano. Valori bassi fanno si che il cerchio/bordo produca un volume basso anche quando viene suonato con forza.","title":"Rim Gain (Risposta dinamica Rim/Edge, 0 \u2013 3.2)"},{"location":"it/roland/trigger_settings/#rim-shot-adjust-risposta-ai-rim-shot-0-80","text":"Quando \u00e8 collegato un PD-125/120/105/85/80R o RT-5S (trigger), potete regolare la sensibilit\u00e0 della risposta del cerchio. Vi sono casi in cui suona anche il cerchio inaspettatamente quando colpite con forza la pelle. Potete migliorare la situazione riducendo il valore di \u201cRimShot Adjust.\u201d Quando impostate un valore troppo basso, pu\u00f2 essere difficile produrre il suono del cerchio.","title":"Rim Shot Adjust (Risposta ai Rim Shot, 0 \u2013 8.0)"},{"location":"it/roland/trigger_settings/#xstick-thrshld-cross-stick-threshold-0-127","text":"Quando \u00e8 collegato un PD-125/120/105/85/80R o RT-5S (trigger), potete determinare il \u201cpunto di incrocio\u201d tra i suoni del cross stick e il rim shot. Impostando questo parametro ad un valore elevato \u00e8 pi\u00f9 facile ottenere i suoni del cross stick. Quando \u00e8 impostato a \u201c0,\u201d suonando un cross stick si produce il suono dell\u2019open rim shot. Alzando eccessivamente il valore, potrebbe suonare il cross stick anche quando eseguite un open rim shot.","title":"XStick Thrshld (Cross Stick Threshold, 0 \u2013 127)"},{"location":"it/teensy/i2c/","text":"Il Teensy 3.x, a differenza della v.2.x e di Arduino, non tollera i 5V ed \u00e8 quindi necessario collegare una resistenza di 'pullup' tra i 3.3V e i corrispettivi segnali. Fonti: * PJRC * Teensy Hauptwerk Projects","title":"I\u00b2C"}]}